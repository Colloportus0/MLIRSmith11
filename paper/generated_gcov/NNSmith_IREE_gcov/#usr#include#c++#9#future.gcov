        -:    0:Source:/usr/include/c++/9/future
        -:    0:Graph:../tools/mlir/lib/Transforms/CMakeFiles/obj.MLIRTransforms.dir/Inliner.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Transforms/CMakeFiles/obj.MLIRTransforms.dir/Inliner.cpp.gcda
        -:    0:Runs:325564
        -:    1:// <future> -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2009-2019 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file include/future
        -:   26: *  This is a Standard C++ Library header.
        -:   27: */
        -:   28:
        -:   29:#ifndef _GLIBCXX_FUTURE
        -:   30:#define _GLIBCXX_FUTURE 1
        -:   31:
        -:   32:#pragma GCC system_header
        -:   33:
        -:   34:#if __cplusplus < 201103L
        -:   35:# include <bits/c++0x_warning.h>
        -:   36:#else
        -:   37:
        -:   38:#include <mutex>
        -:   39:#include <thread>
        -:   40:#include <condition_variable>
        -:   41:#include <system_error>
        -:   42:#include <atomic>
        -:   43:#include <bits/atomic_futex.h>
        -:   44:#include <bits/functexcept.h>
        -:   45:#include <bits/invoke.h>
        -:   46:#include <bits/unique_ptr.h>
        -:   47:#include <bits/shared_ptr.h>
        -:   48:#include <bits/std_function.h>
        -:   49:#include <bits/uses_allocator.h>
        -:   50:#include <bits/allocated_ptr.h>
        -:   51:#include <ext/aligned_buffer.h>
        -:   52:
        -:   53:namespace std _GLIBCXX_VISIBILITY(default)
        -:   54:{
        -:   55:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   56:
        -:   57:  /**
        -:   58:   * @defgroup futures Futures
        -:   59:   * @ingroup concurrency
        -:   60:   *
        -:   61:   * Classes for futures support.
        -:   62:   * @{
        -:   63:   */
        -:   64:
        -:   65:  /// Error code for futures
        -:   66:  enum class future_errc
        -:   67:  {
        -:   68:    future_already_retrieved = 1,
        -:   69:    promise_already_satisfied,
        -:   70:    no_state,
        -:   71:    broken_promise
        -:   72:  };
        -:   73:
        -:   74:  /// Specialization.
        -:   75:  template<>
        -:   76:    struct is_error_code_enum<future_errc> : public true_type { };
        -:   77:
        -:   78:  /// Points to a statically-allocated object derived from error_category.
        -:   79:  const error_category&
        -:   80:  future_category() noexcept;
        -:   81:
        -:   82:  /// Overload for make_error_code.
        -:   83:  inline error_code
    #####:   84:  make_error_code(future_errc __errc) noexcept
    #####:   85:  { return error_code(static_cast<int>(__errc), future_category()); }
call    0 never executed
        -:   86:
        -:   87:  /// Overload for make_error_condition.
        -:   88:  inline error_condition
        -:   89:  make_error_condition(future_errc __errc) noexcept
        -:   90:  { return error_condition(static_cast<int>(__errc), future_category()); }
        -:   91:
        -:   92:  /**
        -:   93:   *  @brief Exception type thrown by futures.
        -:   94:   *  @ingroup exceptions
        -:   95:   */
        -:   96:  class future_error : public logic_error
        -:   97:  {
        -:   98:  public:
        -:   99:    explicit
    #####:  100:    future_error(future_errc __errc)
    #####:  101:    : future_error(std::make_error_code(__errc))
call    0 never executed
        -:  102:    { }
        -:  103:
        -:  104:    virtual ~future_error() noexcept;
        -:  105:
        -:  106:    virtual const char*
        -:  107:    what() const noexcept;
        -:  108:
        -:  109:    const error_code&
        -:  110:    code() const noexcept { return _M_code; }
        -:  111:
        -:  112:  private:
        -:  113:    explicit
function _ZNSt12future_errorC2ESt10error_code called 0 returned 0% blocks executed 0%
    #####:  114:    future_error(error_code __ec)
    #####:  115:    : logic_error("std::future_error: " + __ec.message()), _M_code(__ec)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  116:    { }
        -:  117:
        -:  118:    friend void __throw_future_error(int);
        -:  119:
        -:  120:    error_code 			_M_code;
        -:  121:  };
        -:  122:
        -:  123:  // Forward declarations.
        -:  124:  template<typename _Res>
        -:  125:    class future;
        -:  126:
        -:  127:  template<typename _Res>
        -:  128:    class shared_future;
        -:  129:
        -:  130:  template<typename _Signature>
        -:  131:    class packaged_task;
        -:  132:
        -:  133:  template<typename _Res>
        -:  134:    class promise;
        -:  135:
        -:  136:  /// Launch code for futures
        -:  137:  enum class launch
        -:  138:  {
        -:  139:    async = 1,
        -:  140:    deferred = 2
        -:  141:  };
        -:  142:
        -:  143:  constexpr launch operator&(launch __x, launch __y)
        -:  144:  {
        -:  145:    return static_cast<launch>(
        -:  146:	static_cast<int>(__x) & static_cast<int>(__y));
        -:  147:  }
        -:  148:
        -:  149:  constexpr launch operator|(launch __x, launch __y)
        -:  150:  {
        -:  151:    return static_cast<launch>(
        -:  152:	static_cast<int>(__x) | static_cast<int>(__y));
        -:  153:  }
        -:  154:
        -:  155:  constexpr launch operator^(launch __x, launch __y)
        -:  156:  {
        -:  157:    return static_cast<launch>(
        -:  158:	static_cast<int>(__x) ^ static_cast<int>(__y));
        -:  159:  }
        -:  160:
        -:  161:  constexpr launch operator~(launch __x)
        -:  162:  { return static_cast<launch>(~static_cast<int>(__x)); }
        -:  163:
        -:  164:  inline launch& operator&=(launch& __x, launch __y)
        -:  165:  { return __x = __x & __y; }
        -:  166:
        -:  167:  inline launch& operator|=(launch& __x, launch __y)
        -:  168:  { return __x = __x | __y; }
        -:  169:
        -:  170:  inline launch& operator^=(launch& __x, launch __y)
        -:  171:  { return __x = __x ^ __y; }
        -:  172:
        -:  173:  /// Status code for futures
        -:  174:  enum class future_status
        -:  175:  {
        -:  176:    ready,
        -:  177:    timeout,
        -:  178:    deferred
        -:  179:  };
        -:  180:
        -:  181:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  182:  // 2021. Further incorrect usages of result_of
        -:  183:  template<typename _Fn, typename... _Args>
        -:  184:    using __async_result_of = typename __invoke_result<
        -:  185:      typename decay<_Fn>::type, typename decay<_Args>::type...>::type;
        -:  186:
        -:  187:  template<typename _Fn, typename... _Args>
        -:  188:    future<__async_result_of<_Fn, _Args...>>
        -:  189:    async(launch __policy, _Fn&& __fn, _Args&&... __args);
        -:  190:
        -:  191:  template<typename _Fn, typename... _Args>
        -:  192:    future<__async_result_of<_Fn, _Args...>>
        -:  193:    async(_Fn&& __fn, _Args&&... __args);
        -:  194:
        -:  195:#if defined(_GLIBCXX_HAS_GTHREADS)
        -:  196:
        -:  197:  /// Base class and enclosing scope.
        -:  198:  struct __future_base
        -:  199:  {
        -:  200:    /// Base class for results.
        -:  201:    struct _Result_base
        -:  202:    {
        -:  203:      exception_ptr		_M_error;
        -:  204:
        -:  205:      _Result_base(const _Result_base&) = delete;
        -:  206:      _Result_base& operator=(const _Result_base&) = delete;
        -:  207:
        -:  208:      // _M_destroy() allows derived classes to control deallocation
        -:  209:      virtual void _M_destroy() = 0;
        -:  210:
        -:  211:      struct _Deleter
        -:  212:      {
    #####:  213:	void operator()(_Result_base* __fr) const { __fr->_M_destroy(); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  214:      };
        -:  215:
        -:  216:    protected:
        -:  217:      _Result_base();
        -:  218:      virtual ~_Result_base();
        -:  219:    };
        -:  220:
        -:  221:    /// A unique_ptr for result objects.
        -:  222:    template<typename _Res>
        -:  223:      using _Ptr = unique_ptr<_Res, _Result_base::_Deleter>;
        -:  224:
        -:  225:    /// A result object that has storage for an object of type _Res.
        -:  226:    template<typename _Res>
        -:  227:      struct _Result : _Result_base
        -:  228:      {
        -:  229:      private:
        -:  230:	__gnu_cxx::__aligned_buffer<_Res>	_M_storage;
        -:  231:	bool 					_M_initialized;
        -:  232:
        -:  233:      public:
        -:  234:	typedef _Res result_type;
        -:  235:
        -:  236:	_Result() noexcept : _M_initialized() { }
        -:  237:
        -:  238:	~_Result()
        -:  239:	{
        -:  240:	  if (_M_initialized)
        -:  241:	    _M_value().~_Res();
        -:  242:	}
        -:  243:
        -:  244:	// Return lvalue, future will add const or rvalue-reference
        -:  245:	_Res&
        -:  246:	_M_value() noexcept { return *_M_storage._M_ptr(); }
        -:  247:
        -:  248:	void
        -:  249:	_M_set(const _Res& __res)
        -:  250:	{
        -:  251:	  ::new (_M_storage._M_addr()) _Res(__res);
        -:  252:	  _M_initialized = true;
        -:  253:	}
        -:  254:
        -:  255:	void
        -:  256:	_M_set(_Res&& __res)
        -:  257:	{
        -:  258:	  ::new (_M_storage._M_addr()) _Res(std::move(__res));
        -:  259:	  _M_initialized = true;
        -:  260:	}
        -:  261:
        -:  262:      private:
        -:  263:	void _M_destroy() { delete this; }
        -:  264:    };
        -:  265:
        -:  266:    /// A result object that uses an allocator.
        -:  267:    template<typename _Res, typename _Alloc>
        -:  268:      struct _Result_alloc final : _Result<_Res>, _Alloc
        -:  269:      {
        -:  270:	using __allocator_type = __alloc_rebind<_Alloc, _Result_alloc>;
        -:  271:
        -:  272:        explicit
        -:  273:	_Result_alloc(const _Alloc& __a) : _Result<_Res>(), _Alloc(__a)
        -:  274:	{ }
        -:  275:
        -:  276:      private:
        -:  277:	void _M_destroy()
        -:  278:	{
        -:  279:	  __allocator_type __a(*this);
        -:  280:	  __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
        -:  281:	  this->~_Result_alloc();
        -:  282:	}
        -:  283:      };
        -:  284:
        -:  285:    // Create a result object that uses an allocator.
        -:  286:    template<typename _Res, typename _Allocator>
        -:  287:      static _Ptr<_Result_alloc<_Res, _Allocator>>
        -:  288:      _S_allocate_result(const _Allocator& __a)
        -:  289:      {
        -:  290:	using __result_type = _Result_alloc<_Res, _Allocator>;
        -:  291:	typename __result_type::__allocator_type __a2(__a);
        -:  292:	auto __guard = std::__allocate_guarded(__a2);
        -:  293:	__result_type* __p = ::new((void*)__guard.get()) __result_type{__a};
        -:  294:	__guard = nullptr;
        -:  295:	return _Ptr<__result_type>(__p);
        -:  296:      }
        -:  297:
        -:  298:    // Keep it simple for std::allocator.
        -:  299:    template<typename _Res, typename _Tp>
        -:  300:      static _Ptr<_Result<_Res>>
        -:  301:      _S_allocate_result(const std::allocator<_Tp>& __a)
        -:  302:      {
        -:  303:	return _Ptr<_Result<_Res>>(new _Result<_Res>);
        -:  304:      }
        -:  305:
        -:  306:    // Base class for various types of shared state created by an
        -:  307:    // asynchronous provider (such as a std::promise) and shared with one
        -:  308:    // or more associated futures.
        -:  309:    class _State_baseV2
        -:  310:    {
        -:  311:      typedef _Ptr<_Result_base> _Ptr_type;
        -:  312:
        -:  313:      enum _Status : unsigned {
        -:  314:	__not_ready,
        -:  315:	__ready
        -:  316:      };
        -:  317:
        -:  318:      _Ptr_type			_M_result;
        -:  319:      __atomic_futex_unsigned<>	_M_status;
        -:  320:      atomic_flag         	_M_retrieved = ATOMIC_FLAG_INIT;
        -:  321:      once_flag			_M_once;
        -:  322:
        -:  323:    public:
    #####:  324:      _State_baseV2() noexcept : _M_result(), _M_status(_Status::__not_ready)
        -:  325:	{ }
        -:  326:      _State_baseV2(const _State_baseV2&) = delete;
        -:  327:      _State_baseV2& operator=(const _State_baseV2&) = delete;
    #####:  328:      virtual ~_State_baseV2() = default;
------------------
_ZNSt13__future_base13_State_baseV2D0Ev:
function _ZNSt13__future_base13_State_baseV2D0Ev called 0 returned 0% blocks executed 0%
    #####:  328:      virtual ~_State_baseV2() = default;
branch  0 never executed
branch  1 never executed
call    2 never executed
------------------
_ZNSt13__future_base13_State_baseV2D2Ev:
function _ZNSt13__future_base13_State_baseV2D2Ev called 0 returned 0% blocks executed 0%
    #####:  328:      virtual ~_State_baseV2() = default;
branch  0 never executed
branch  1 never executed
------------------
        -:  329:
        -:  330:      _Result_base&
        -:  331:      wait()
        -:  332:      {
        -:  333:	// Run any deferred function or join any asynchronous thread:
        -:  334:	_M_complete_async();
        -:  335:	// Acquire MO makes sure this synchronizes with the thread that made
        -:  336:	// the future ready.
        -:  337:	_M_status._M_load_when_equal(_Status::__ready, memory_order_acquire);
        -:  338:	return *_M_result;
        -:  339:      }
        -:  340:
        -:  341:      template<typename _Rep, typename _Period>
        -:  342:        future_status
        -:  343:        wait_for(const chrono::duration<_Rep, _Period>& __rel)
        -:  344:        {
        -:  345:	  // First, check if the future has been made ready.  Use acquire MO
        -:  346:	  // to synchronize with the thread that made it ready.
        -:  347:	  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)
        -:  348:	    return future_status::ready;
        -:  349:	  if (_M_is_deferred_future())
        -:  350:	    return future_status::deferred;
        -:  351:	  if (_M_status._M_load_when_equal_for(_Status::__ready,
        -:  352:	      memory_order_acquire, __rel))
        -:  353:	    {
        -:  354:	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  355:	      // 2100.  timed waiting functions must also join
        -:  356:	      // This call is a no-op by default except on an async future,
        -:  357:	      // in which case the async thread is joined.  It's also not a
        -:  358:	      // no-op for a deferred future, but such a future will never
        -:  359:	      // reach this point because it returns future_status::deferred
        -:  360:	      // instead of waiting for the future to become ready (see
        -:  361:	      // above).  Async futures synchronize in this call, so we need
        -:  362:	      // no further synchronization here.
        -:  363:	      _M_complete_async();
        -:  364:
        -:  365:	      return future_status::ready;
        -:  366:	    }
        -:  367:	  return future_status::timeout;
        -:  368:	}
        -:  369:
        -:  370:      template<typename _Clock, typename _Duration>
        -:  371:        future_status
        -:  372:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs)
        -:  373:        {
        -:  374:	  // First, check if the future has been made ready.  Use acquire MO
        -:  375:	  // to synchronize with the thread that made it ready.
        -:  376:	  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)
        -:  377:	    return future_status::ready;
        -:  378:	  if (_M_is_deferred_future())
        -:  379:	    return future_status::deferred;
        -:  380:	  if (_M_status._M_load_when_equal_until(_Status::__ready,
        -:  381:	      memory_order_acquire, __abs))
        -:  382:	    {
        -:  383:	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  384:	      // 2100.  timed waiting functions must also join
        -:  385:	      // See wait_for(...) above.
        -:  386:	      _M_complete_async();
        -:  387:
        -:  388:	      return future_status::ready;
        -:  389:	    }
        -:  390:	  return future_status::timeout;
        -:  391:	}
        -:  392:
        -:  393:      // Provide a result to the shared state and make it ready.
        -:  394:      // Calls at most once: _M_result = __res();
        -:  395:      void
function _ZNSt13__future_base13_State_baseV213_M_set_resultESt8functionIFSt10unique_ptrINS_12_Result_baseENS3_8_DeleterEEvEEb called 0 returned 0% blocks executed 0%
    #####:  396:      _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)
        -:  397:      {
    #####:  398:	bool __did_set = false;
        -:  399:        // all calls to this function are serialized,
        -:  400:        // side-effects of invoking __res only happen once
    #####:  401:	call_once(_M_once, &_State_baseV2::_M_do_set, this,
call    0 never executed
    #####:  402:		  std::__addressof(__res), std::__addressof(__did_set));
call    0 never executed
    #####:  403:	if (__did_set)
branch  0 never executed
branch  1 never executed
        -:  404:	  // Use release MO to synchronize with observers of the ready state.
    #####:  405:	  _M_status._M_store_notify_all(_Status::__ready,
branch  0 never executed
branch  1 never executed
        -:  406:					memory_order_release);
    #####:  407:	else if (!__ignore_failure)
branch  0 never executed
branch  1 never executed
    #####:  408:          __throw_future_error(int(future_errc::promise_already_satisfied));
call    0 never executed
    #####:  409:      }
        -:  410:
        -:  411:      // Provide a result to the shared state but delay making it ready
        -:  412:      // until the calling thread exits.
        -:  413:      // Calls at most once: _M_result = __res();
        -:  414:      void
        -:  415:      _M_set_delayed_result(function<_Ptr_type()> __res,
        -:  416:			    weak_ptr<_State_baseV2> __self)
        -:  417:      {
        -:  418:	bool __did_set = false;
        -:  419:	unique_ptr<_Make_ready> __mr{new _Make_ready};
        -:  420:        // all calls to this function are serialized,
        -:  421:        // side-effects of invoking __res only happen once
        -:  422:	call_once(_M_once, &_State_baseV2::_M_do_set, this,
        -:  423:		  std::__addressof(__res), std::__addressof(__did_set));
        -:  424:	if (!__did_set)
        -:  425:          __throw_future_error(int(future_errc::promise_already_satisfied));
        -:  426:	__mr->_M_shared_state = std::move(__self);
        -:  427:	__mr->_M_set();
        -:  428:	__mr.release();
        -:  429:      }
        -:  430:
        -:  431:      // Abandon this shared state.
        -:  432:      void
function _ZNSt13__future_base13_State_baseV216_M_break_promiseESt10unique_ptrINS_12_Result_baseENS2_8_DeleterEE called 0 returned 0% blocks executed 0%
    #####:  433:      _M_break_promise(_Ptr_type __res)
        -:  434:      {
    #####:  435:	if (static_cast<bool>(__res))
branch  0 never executed
branch  1 never executed
        -:  436:	  {
    #####:  437:	    __res->_M_error =
call    0 never executed
call    1 never executed
    #####:  438:	      make_exception_ptr(future_error(future_errc::broken_promise));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  439:	    // This function is only called when the last asynchronous result
        -:  440:	    // provider is abandoning this shared state, so noone can be
        -:  441:	    // trying to make the shared state ready at the same time, and
        -:  442:	    // we can access _M_result directly instead of through call_once.
    #####:  443:	    _M_result.swap(__res);
branch  0 never executed
branch  1 never executed
        -:  444:	    // Use release MO to synchronize with observers of the ready state.
    #####:  445:	    _M_status._M_store_notify_all(_Status::__ready,
branch  0 never executed
branch  1 never executed
        -:  446:					  memory_order_release);
        -:  447:	  }
    #####:  448:      }
        -:  449:
        -:  450:      // Called when this object is first passed to a future.
        -:  451:      void
function _ZNSt13__future_base13_State_baseV221_M_set_retrieved_flagEv called 0 returned 0% blocks executed 0%
    #####:  452:      _M_set_retrieved_flag()
        -:  453:      {
    #####:  454:	if (_M_retrieved.test_and_set())
branch  0 never executed
branch  1 never executed
    #####:  455:	  __throw_future_error(int(future_errc::future_already_retrieved));
call    0 never executed
    #####:  456:      }
        -:  457:
        -:  458:      template<typename _Res, typename _Arg>
        -:  459:        struct _Setter;
        -:  460:
        -:  461:      // set lvalues
        -:  462:      template<typename _Res, typename _Arg>
        -:  463:        struct _Setter<_Res, _Arg&>
        -:  464:        {
        -:  465:          // check this is only used by promise<R>::set_value(const R&)
        -:  466:          // or promise<R&>::set_value(R&)
        -:  467:          static_assert(is_same<_Res, _Arg&>::value  // promise<R&>
        -:  468:              || is_same<const _Res, _Arg>::value,   // promise<R>
        -:  469:              "Invalid specialisation");
        -:  470:
        -:  471:	  // Used by std::promise to copy construct the result.
        -:  472:          typename promise<_Res>::_Ptr_type operator()() const
        -:  473:          {
        -:  474:            _M_promise->_M_storage->_M_set(*_M_arg);
        -:  475:            return std::move(_M_promise->_M_storage);
        -:  476:          }
        -:  477:          promise<_Res>*    _M_promise;
        -:  478:          _Arg*             _M_arg;
        -:  479:        };
        -:  480:
        -:  481:      // set rvalues
        -:  482:      template<typename _Res>
        -:  483:        struct _Setter<_Res, _Res&&>
        -:  484:        {
        -:  485:	  // Used by std::promise to move construct the result.
        -:  486:          typename promise<_Res>::_Ptr_type operator()() const
        -:  487:          {
        -:  488:            _M_promise->_M_storage->_M_set(std::move(*_M_arg));
        -:  489:            return std::move(_M_promise->_M_storage);
        -:  490:          }
        -:  491:          promise<_Res>*    _M_promise;
        -:  492:          _Res*             _M_arg;
        -:  493:        };
        -:  494:
        -:  495:      // set void
        -:  496:      template<typename _Res>
        -:  497:	struct _Setter<_Res, void>
        -:  498:	{
        -:  499:	  static_assert(is_void<_Res>::value, "Only used for promise<void>");
        -:  500:
    #####:  501:	  typename promise<_Res>::_Ptr_type operator()() const
    #####:  502:	  { return std::move(_M_promise->_M_storage); }
        -:  503:
        -:  504:	  promise<_Res>*    _M_promise;
        -:  505:	};
        -:  506:
        -:  507:      struct __exception_ptr_tag { };
        -:  508:
        -:  509:      // set exceptions
        -:  510:      template<typename _Res>
        -:  511:        struct _Setter<_Res, __exception_ptr_tag>
        -:  512:        {
        -:  513:	  // Used by std::promise to store an exception as the result.
        -:  514:          typename promise<_Res>::_Ptr_type operator()() const
        -:  515:          {
        -:  516:            _M_promise->_M_storage->_M_error = *_M_ex;
        -:  517:            return std::move(_M_promise->_M_storage);
        -:  518:          }
        -:  519:
        -:  520:          promise<_Res>*   _M_promise;
        -:  521:          exception_ptr*    _M_ex;
        -:  522:        };
        -:  523:
        -:  524:      template<typename _Res, typename _Arg>
        -:  525:        static _Setter<_Res, _Arg&&>
        -:  526:        __setter(promise<_Res>* __prom, _Arg&& __arg)
        -:  527:        {
        -:  528:	  _S_check(__prom->_M_future);
        -:  529:          return _Setter<_Res, _Arg&&>{ __prom, std::__addressof(__arg) };
        -:  530:        }
        -:  531:
        -:  532:      template<typename _Res>
        -:  533:        static _Setter<_Res, __exception_ptr_tag>
        -:  534:        __setter(exception_ptr& __ex, promise<_Res>* __prom)
        -:  535:        {
        -:  536:	  _S_check(__prom->_M_future);
        -:  537:          return _Setter<_Res, __exception_ptr_tag>{ __prom, &__ex };
        -:  538:        }
        -:  539:
        -:  540:      template<typename _Res>
        -:  541:	static _Setter<_Res, void>
    #####:  542:	__setter(promise<_Res>* __prom)
        -:  543:	{
    #####:  544:	  _S_check(__prom->_M_future);
        -:  545:	  return _Setter<_Res, void>{ __prom };
        -:  546:	}
        -:  547:
        -:  548:      template<typename _Tp>
        -:  549:        static void
    #####:  550:        _S_check(const shared_ptr<_Tp>& __p)
        -:  551:        {
    #####:  552:          if (!static_cast<bool>(__p))
branch  0 never executed
branch  1 never executed
    #####:  553:            __throw_future_error((int)future_errc::no_state);
call    0 never executed
call    1 never executed
        -:  554:        }
        -:  555:
        -:  556:    private:
        -:  557:      // The function invoked with std::call_once(_M_once, ...).
        -:  558:      void
function _ZNSt13__future_base13_State_baseV29_M_do_setEPSt8functionIFSt10unique_ptrINS_12_Result_baseENS3_8_DeleterEEvEEPb called 0 returned 0% blocks executed 0%
    #####:  559:      _M_do_set(function<_Ptr_type()>* __f, bool* __did_set)
        -:  560:      {
    #####:  561:        _Ptr_type __res = (*__f)();
branch  0 never executed
branch  1 never executed
        -:  562:        // Notify the caller that we did try to set; if we do not throw an
        -:  563:        // exception, the caller will be aware that it did set (e.g., see
        -:  564:        // _M_set_result).
    #####:  565:	*__did_set = true;
    #####:  566:        _M_result.swap(__res); // nothrow
branch  0 never executed
branch  1 never executed
    #####:  567:      }
        -:  568:
        -:  569:      // Wait for completion of async function.
function _ZNSt13__future_base13_State_baseV217_M_complete_asyncEv called 0 returned 0% blocks executed 0%
    #####:  570:      virtual void _M_complete_async() { }
        -:  571:
        -:  572:      // Return true if state corresponds to a deferred function.
function _ZNKSt13__future_base13_State_baseV221_M_is_deferred_futureEv called 0 returned 0% blocks executed 0%
    #####:  573:      virtual bool _M_is_deferred_future() const { return false; }
        -:  574:
        -:  575:      struct _Make_ready final : __at_thread_exit_elt
        -:  576:      {
        -:  577:	weak_ptr<_State_baseV2> _M_shared_state;
        -:  578:	static void _S_run(void*);
        -:  579:	void _M_set();
        -:  580:      };
        -:  581:    };
        -:  582:
        -:  583:#ifdef _GLIBCXX_ASYNC_ABI_COMPAT
        -:  584:    class _State_base;
        -:  585:    class _Async_state_common;
        -:  586:#else
        -:  587:    using _State_base = _State_baseV2;
        -:  588:    class _Async_state_commonV2;
        -:  589:#endif
        -:  590:
        -:  591:    template<typename _BoundFn,
        -:  592:	     typename _Res = decltype(std::declval<_BoundFn&>()())>
        -:  593:      class _Deferred_state;
        -:  594:
        -:  595:    template<typename _BoundFn,
        -:  596:	     typename _Res = decltype(std::declval<_BoundFn&>()())>
        -:  597:      class _Async_state_impl;
        -:  598:
        -:  599:    template<typename _Signature>
        -:  600:      class _Task_state_base;
        -:  601:
        -:  602:    template<typename _Fn, typename _Alloc, typename _Signature>
        -:  603:      class _Task_state;
        -:  604:
        -:  605:    template<typename _BoundFn>
        -:  606:      static std::shared_ptr<_State_base>
        -:  607:      _S_make_deferred_state(_BoundFn&& __fn);
        -:  608:
        -:  609:    template<typename _BoundFn>
        -:  610:      static std::shared_ptr<_State_base>
        -:  611:      _S_make_async_state(_BoundFn&& __fn);
        -:  612:
        -:  613:    template<typename _Res_ptr, typename _Fn,
        -:  614:	     typename _Res = typename _Res_ptr::element_type::result_type>
        -:  615:      struct _Task_setter;
        -:  616:
        -:  617:    template<typename _Res_ptr, typename _BoundFn>
        -:  618:      static _Task_setter<_Res_ptr, _BoundFn>
        -:  619:      _S_task_setter(_Res_ptr& __ptr, _BoundFn& __call)
        -:  620:      {
        -:  621:	return { std::__addressof(__ptr), std::__addressof(__call) };
        -:  622:      }
        -:  623:  };
        -:  624:
        -:  625:  /// Partial specialization for reference types.
        -:  626:  template<typename _Res>
        -:  627:    struct __future_base::_Result<_Res&> : __future_base::_Result_base
        -:  628:    {
        -:  629:      typedef _Res& result_type;
        -:  630:
        -:  631:      _Result() noexcept : _M_value_ptr() { }
        -:  632:
        -:  633:      void
        -:  634:      _M_set(_Res& __res) noexcept
        -:  635:      { _M_value_ptr = std::addressof(__res); }
        -:  636:
        -:  637:      _Res& _M_get() noexcept { return *_M_value_ptr; }
        -:  638:
        -:  639:    private:
        -:  640:      _Res* 			_M_value_ptr;
        -:  641:
        -:  642:      void _M_destroy() { delete this; }
        -:  643:    };
        -:  644:
        -:  645:  /// Explicit specialization for void.
        -:  646:  template<>
    #####:  647:    struct __future_base::_Result<void> : __future_base::_Result_base
        -:  648:    {
        -:  649:      typedef void result_type;
        -:  650:
        -:  651:    private:
function _ZNSt13__future_base7_ResultIvE10_M_destroyEv called 0 returned 0% blocks executed 0%
    #####:  652:      void _M_destroy() { delete this; }
call    0 never executed
        -:  653:    };
        -:  654:
        -:  655:#ifndef _GLIBCXX_ASYNC_ABI_COMPAT
        -:  656:
        -:  657:  // Allow _Setter objects to be stored locally in std::function
        -:  658:  template<typename _Res, typename _Arg>
        -:  659:    struct __is_location_invariant
        -:  660:    <__future_base::_State_base::_Setter<_Res, _Arg>>
        -:  661:    : true_type { };
        -:  662:
        -:  663:  // Allow _Task_setter objects to be stored locally in std::function
        -:  664:  template<typename _Res_ptr, typename _Fn, typename _Res>
        -:  665:    struct __is_location_invariant
        -:  666:    <__future_base::_Task_setter<_Res_ptr, _Fn, _Res>>
        -:  667:    : true_type { };
        -:  668:
        -:  669:  /// Common implementation for future and shared_future.
        -:  670:  template<typename _Res>
    #####:  671:    class __basic_future : public __future_base
        -:  672:    {
        -:  673:    protected:
        -:  674:      typedef shared_ptr<_State_base>		__state_type;
        -:  675:      typedef __future_base::_Result<_Res>&	__result_type;
        -:  676:
        -:  677:    private:
        -:  678:      __state_type 		_M_state;
        -:  679:
        -:  680:    public:
        -:  681:      // Disable copying.
        -:  682:      __basic_future(const __basic_future&) = delete;
        -:  683:      __basic_future& operator=(const __basic_future&) = delete;
        -:  684:
        -:  685:      bool
        -:  686:      valid() const noexcept { return static_cast<bool>(_M_state); }
        -:  687:
        -:  688:      void
        -:  689:      wait() const
        -:  690:      {
        -:  691:        _State_base::_S_check(_M_state);
        -:  692:        _M_state->wait();
        -:  693:      }
        -:  694:
        -:  695:      template<typename _Rep, typename _Period>
        -:  696:        future_status
        -:  697:        wait_for(const chrono::duration<_Rep, _Period>& __rel) const
        -:  698:        {
        -:  699:          _State_base::_S_check(_M_state);
        -:  700:          return _M_state->wait_for(__rel);
        -:  701:        }
        -:  702:
        -:  703:      template<typename _Clock, typename _Duration>
        -:  704:        future_status
        -:  705:        wait_until(const chrono::time_point<_Clock, _Duration>& __abs) const
        -:  706:        {
        -:  707:          _State_base::_S_check(_M_state);
        -:  708:          return _M_state->wait_until(__abs);
        -:  709:        }
        -:  710:
        -:  711:    protected:
        -:  712:      /// Wait for the state to be ready and rethrow any stored exception
        -:  713:      __result_type
        -:  714:      _M_get_result() const
        -:  715:      {
        -:  716:        _State_base::_S_check(_M_state);
        -:  717:        _Result_base& __res = _M_state->wait();
        -:  718:        if (!(__res._M_error == 0))
        -:  719:          rethrow_exception(__res._M_error);
        -:  720:        return static_cast<__result_type>(__res);
        -:  721:      }
        -:  722:
        -:  723:      void _M_swap(__basic_future& __that) noexcept
        -:  724:      {
        -:  725:        _M_state.swap(__that._M_state);
        -:  726:      }
        -:  727:
        -:  728:      // Construction of a future by promise::get_future()
        -:  729:      explicit
function _ZNSt14__basic_futureIvEC2ERKSt10shared_ptrINSt13__future_base13_State_baseV2EE called 0 returned 0% blocks executed 0%
    #####:  730:      __basic_future(const __state_type& __state) : _M_state(__state)
call    0 never executed
        -:  731:      {
    #####:  732:        _State_base::_S_check(_M_state);
branch  0 never executed
branch  1 never executed
    #####:  733:        _M_state->_M_set_retrieved_flag();
call    0 never executed
    #####:  734:      }
        -:  735:
        -:  736:      // Copy construction from a shared_future
        -:  737:      explicit
        -:  738:      __basic_future(const shared_future<_Res>&) noexcept;
        -:  739:
        -:  740:      // Move construction from a shared_future
        -:  741:      explicit
        -:  742:      __basic_future(shared_future<_Res>&&) noexcept;
        -:  743:
        -:  744:      // Move construction from a future
        -:  745:      explicit
        -:  746:      __basic_future(future<_Res>&&) noexcept;
        -:  747:
        -:  748:      constexpr __basic_future() noexcept : _M_state() { }
        -:  749:
        -:  750:      struct _Reset
        -:  751:      {
        -:  752:        explicit _Reset(__basic_future& __fut) noexcept : _M_fut(__fut) { }
        -:  753:        ~_Reset() { _M_fut._M_state.reset(); }
        -:  754:        __basic_future& _M_fut;
        -:  755:      };
        -:  756:    };
        -:  757:
        -:  758:
        -:  759:  /// Primary template for future.
        -:  760:  template<typename _Res>
        -:  761:    class future : public __basic_future<_Res>
        -:  762:    {
        -:  763:      friend class promise<_Res>;
        -:  764:      template<typename> friend class packaged_task;
        -:  765:      template<typename _Fn, typename... _Args>
        -:  766:        friend future<__async_result_of<_Fn, _Args...>>
        -:  767:        async(launch, _Fn&&, _Args&&...);
        -:  768:
        -:  769:      typedef __basic_future<_Res> _Base_type;
        -:  770:      typedef typename _Base_type::__state_type __state_type;
        -:  771:
        -:  772:      explicit
        -:  773:      future(const __state_type& __state) : _Base_type(__state) { }
        -:  774:
        -:  775:    public:
        -:  776:      constexpr future() noexcept : _Base_type() { }
        -:  777:
        -:  778:      /// Move constructor
        -:  779:      future(future&& __uf) noexcept : _Base_type(std::move(__uf)) { }
        -:  780:
        -:  781:      // Disable copying
        -:  782:      future(const future&) = delete;
        -:  783:      future& operator=(const future&) = delete;
        -:  784:
        -:  785:      future& operator=(future&& __fut) noexcept
        -:  786:      {
        -:  787:        future(std::move(__fut))._M_swap(*this);
        -:  788:        return *this;
        -:  789:      }
        -:  790:
        -:  791:      /// Retrieving the value
        -:  792:      _Res
        -:  793:      get()
        -:  794:      {
        -:  795:        typename _Base_type::_Reset __reset(*this);
        -:  796:        return std::move(this->_M_get_result()._M_value());
        -:  797:      }
        -:  798:
        -:  799:      shared_future<_Res> share() noexcept;
        -:  800:    };
        -:  801:
        -:  802:  /// Partial specialization for future<R&>
        -:  803:  template<typename _Res>
        -:  804:    class future<_Res&> : public __basic_future<_Res&>
        -:  805:    {
        -:  806:      friend class promise<_Res&>;
        -:  807:      template<typename> friend class packaged_task;
        -:  808:      template<typename _Fn, typename... _Args>
        -:  809:        friend future<__async_result_of<_Fn, _Args...>>
        -:  810:        async(launch, _Fn&&, _Args&&...);
        -:  811:
        -:  812:      typedef __basic_future<_Res&> _Base_type;
        -:  813:      typedef typename _Base_type::__state_type __state_type;
        -:  814:
        -:  815:      explicit
        -:  816:      future(const __state_type& __state) : _Base_type(__state) { }
        -:  817:
        -:  818:    public:
        -:  819:      constexpr future() noexcept : _Base_type() { }
        -:  820:
        -:  821:      /// Move constructor
        -:  822:      future(future&& __uf) noexcept : _Base_type(std::move(__uf)) { }
        -:  823:
        -:  824:      // Disable copying
        -:  825:      future(const future&) = delete;
        -:  826:      future& operator=(const future&) = delete;
        -:  827:
        -:  828:      future& operator=(future&& __fut) noexcept
        -:  829:      {
        -:  830:        future(std::move(__fut))._M_swap(*this);
        -:  831:        return *this;
        -:  832:      }
        -:  833:
        -:  834:      /// Retrieving the value
        -:  835:      _Res&
        -:  836:      get()
        -:  837:      {
        -:  838:        typename _Base_type::_Reset __reset(*this);
        -:  839:        return this->_M_get_result()._M_get();
        -:  840:      }
        -:  841:
        -:  842:      shared_future<_Res&> share() noexcept;
        -:  843:    };
        -:  844:
        -:  845:  /// Explicit specialization for future<void>
        -:  846:  template<>
    #####:  847:    class future<void> : public __basic_future<void>
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  848:    {
        -:  849:      friend class promise<void>;
        -:  850:      template<typename> friend class packaged_task;
        -:  851:      template<typename _Fn, typename... _Args>
        -:  852:        friend future<__async_result_of<_Fn, _Args...>>
        -:  853:        async(launch, _Fn&&, _Args&&...);
        -:  854:
        -:  855:      typedef __basic_future<void> _Base_type;
        -:  856:      typedef typename _Base_type::__state_type __state_type;
        -:  857:
        -:  858:      explicit
    #####:  859:      future(const __state_type& __state) : _Base_type(__state) { }
        -:  860:
        -:  861:    public:
        -:  862:      constexpr future() noexcept : _Base_type() { }
        -:  863:
        -:  864:      /// Move constructor
    #####:  865:      future(future&& __uf) noexcept : _Base_type(std::move(__uf)) { }
        -:  866:
        -:  867:      // Disable copying
        -:  868:      future(const future&) = delete;
        -:  869:      future& operator=(const future&) = delete;
        -:  870:
        -:  871:      future& operator=(future&& __fut) noexcept
        -:  872:      {
        -:  873:        future(std::move(__fut))._M_swap(*this);
        -:  874:        return *this;
        -:  875:      }
        -:  876:
        -:  877:      /// Retrieving the value
        -:  878:      void
        -:  879:      get()
        -:  880:      {
        -:  881:        typename _Base_type::_Reset __reset(*this);
        -:  882:        this->_M_get_result();
        -:  883:      }
        -:  884:
        -:  885:      shared_future<void> share() noexcept;
        -:  886:    };
        -:  887:
        -:  888:
        -:  889:  /// Primary template for shared_future.
        -:  890:  template<typename _Res>
        -:  891:    class shared_future : public __basic_future<_Res>
        -:  892:    {
        -:  893:      typedef __basic_future<_Res> _Base_type;
        -:  894:
        -:  895:    public:
        -:  896:      constexpr shared_future() noexcept : _Base_type() { }
        -:  897:
        -:  898:      /// Copy constructor
        -:  899:      shared_future(const shared_future& __sf) noexcept : _Base_type(__sf) { }
        -:  900:
        -:  901:      /// Construct from a future rvalue
        -:  902:      shared_future(future<_Res>&& __uf) noexcept
        -:  903:      : _Base_type(std::move(__uf))
        -:  904:      { }
        -:  905:
        -:  906:      /// Construct from a shared_future rvalue
        -:  907:      shared_future(shared_future&& __sf) noexcept
        -:  908:      : _Base_type(std::move(__sf))
        -:  909:      { }
        -:  910:
        -:  911:      shared_future& operator=(const shared_future& __sf) noexcept
        -:  912:      {
        -:  913:        shared_future(__sf)._M_swap(*this);
        -:  914:        return *this;
        -:  915:      }
        -:  916:
        -:  917:      shared_future& operator=(shared_future&& __sf) noexcept
        -:  918:      {
        -:  919:        shared_future(std::move(__sf))._M_swap(*this);
        -:  920:        return *this;
        -:  921:      }
        -:  922:
        -:  923:      /// Retrieving the value
        -:  924:      const _Res&
        -:  925:      get() const { return this->_M_get_result()._M_value(); }
        -:  926:    };
        -:  927:
        -:  928:  /// Partial specialization for shared_future<R&>
        -:  929:  template<typename _Res>
        -:  930:    class shared_future<_Res&> : public __basic_future<_Res&>
        -:  931:    {
        -:  932:      typedef __basic_future<_Res&>           _Base_type;
        -:  933:
        -:  934:    public:
        -:  935:      constexpr shared_future() noexcept : _Base_type() { }
        -:  936:
        -:  937:      /// Copy constructor
        -:  938:      shared_future(const shared_future& __sf) : _Base_type(__sf) { }
        -:  939:
        -:  940:      /// Construct from a future rvalue
        -:  941:      shared_future(future<_Res&>&& __uf) noexcept
        -:  942:      : _Base_type(std::move(__uf))
        -:  943:      { }
        -:  944:
        -:  945:      /// Construct from a shared_future rvalue
        -:  946:      shared_future(shared_future&& __sf) noexcept
        -:  947:      : _Base_type(std::move(__sf))
        -:  948:      { }
        -:  949:
        -:  950:      shared_future& operator=(const shared_future& __sf)
        -:  951:      {
        -:  952:        shared_future(__sf)._M_swap(*this);
        -:  953:        return *this;
        -:  954:      }
        -:  955:
        -:  956:      shared_future& operator=(shared_future&& __sf) noexcept
        -:  957:      {
        -:  958:        shared_future(std::move(__sf))._M_swap(*this);
        -:  959:        return *this;
        -:  960:      }
        -:  961:
        -:  962:      /// Retrieving the value
        -:  963:      _Res&
        -:  964:      get() const { return this->_M_get_result()._M_get(); }
        -:  965:    };
        -:  966:
        -:  967:  /// Explicit specialization for shared_future<void>
        -:  968:  template<>
    #####:  969:    class shared_future<void> : public __basic_future<void>
branch  0 never executed
branch  1 never executed
        -:  970:    {
        -:  971:      typedef __basic_future<void> _Base_type;
        -:  972:
        -:  973:    public:
        -:  974:      constexpr shared_future() noexcept : _Base_type() { }
        -:  975:
        -:  976:      /// Copy constructor
        -:  977:      shared_future(const shared_future& __sf) : _Base_type(__sf) { }
        -:  978:
        -:  979:      /// Construct from a future rvalue
    #####:  980:      shared_future(future<void>&& __uf) noexcept
    #####:  981:      : _Base_type(std::move(__uf))
        -:  982:      { }
        -:  983:
        -:  984:      /// Construct from a shared_future rvalue
        -:  985:      shared_future(shared_future&& __sf) noexcept
        -:  986:      : _Base_type(std::move(__sf))
        -:  987:      { }
        -:  988:
        -:  989:      shared_future& operator=(const shared_future& __sf)
        -:  990:      {
        -:  991:        shared_future(__sf)._M_swap(*this);
        -:  992:        return *this;
        -:  993:      }
        -:  994:
        -:  995:      shared_future& operator=(shared_future&& __sf) noexcept
        -:  996:      {
        -:  997:        shared_future(std::move(__sf))._M_swap(*this);
        -:  998:        return *this;
        -:  999:      }
        -: 1000:
        -: 1001:      // Retrieving the value
        -: 1002:      void
        -: 1003:      get() const { this->_M_get_result(); }
        -: 1004:    };
        -: 1005:
        -: 1006:  // Now we can define the protected __basic_future constructors.
        -: 1007:  template<typename _Res>
        -: 1008:    inline __basic_future<_Res>::
        -: 1009:    __basic_future(const shared_future<_Res>& __sf) noexcept
        -: 1010:    : _M_state(__sf._M_state)
        -: 1011:    { }
        -: 1012:
        -: 1013:  template<typename _Res>
        -: 1014:    inline __basic_future<_Res>::
        -: 1015:    __basic_future(shared_future<_Res>&& __sf) noexcept
        -: 1016:    : _M_state(std::move(__sf._M_state))
        -: 1017:    { }
        -: 1018:
        -: 1019:  template<typename _Res>
    #####: 1020:    inline __basic_future<_Res>::
        -: 1021:    __basic_future(future<_Res>&& __uf) noexcept
    #####: 1022:    : _M_state(std::move(__uf._M_state))
call    0 never executed
        -: 1023:    { }
        -: 1024:
        -: 1025:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1026:  // 2556. Wide contract for future::share()
        -: 1027:  template<typename _Res>
        -: 1028:    inline shared_future<_Res>
        -: 1029:    future<_Res>::share() noexcept
        -: 1030:    { return shared_future<_Res>(std::move(*this)); }
        -: 1031:
        -: 1032:  template<typename _Res>
        -: 1033:    inline shared_future<_Res&>
        -: 1034:    future<_Res&>::share() noexcept
        -: 1035:    { return shared_future<_Res&>(std::move(*this)); }
        -: 1036:
        -: 1037:  inline shared_future<void>
    #####: 1038:  future<void>::share() noexcept
    #####: 1039:  { return shared_future<void>(std::move(*this)); }
call    0 never executed
        -: 1040:
        -: 1041:  /// Primary template for promise
        -: 1042:  template<typename _Res>
        -: 1043:    class promise
        -: 1044:    {
        -: 1045:      typedef __future_base::_State_base 	_State;
        -: 1046:      typedef __future_base::_Result<_Res>	_Res_type;
        -: 1047:      typedef __future_base::_Ptr<_Res_type>	_Ptr_type;
        -: 1048:      template<typename, typename> friend class _State::_Setter;
        -: 1049:      friend _State;
        -: 1050:
        -: 1051:      shared_ptr<_State>                        _M_future;
        -: 1052:      _Ptr_type                                 _M_storage;
        -: 1053:
        -: 1054:    public:
        -: 1055:      promise()
        -: 1056:      : _M_future(std::make_shared<_State>()),
        -: 1057:	_M_storage(new _Res_type())
        -: 1058:      { }
        -: 1059:
        -: 1060:      promise(promise&& __rhs) noexcept
        -: 1061:      : _M_future(std::move(__rhs._M_future)),
        -: 1062:	_M_storage(std::move(__rhs._M_storage))
        -: 1063:      { }
        -: 1064:
        -: 1065:      template<typename _Allocator>
        -: 1066:        promise(allocator_arg_t, const _Allocator& __a)
        -: 1067:        : _M_future(std::allocate_shared<_State>(__a)),
        -: 1068:	  _M_storage(__future_base::_S_allocate_result<_Res>(__a))
        -: 1069:        { }
        -: 1070:
        -: 1071:      template<typename _Allocator>
        -: 1072:        promise(allocator_arg_t, const _Allocator&, promise&& __rhs)
        -: 1073:        : _M_future(std::move(__rhs._M_future)),
        -: 1074:	  _M_storage(std::move(__rhs._M_storage))
        -: 1075:        { }
        -: 1076:
        -: 1077:      promise(const promise&) = delete;
        -: 1078:
        -: 1079:      ~promise()
        -: 1080:      {
        -: 1081:        if (static_cast<bool>(_M_future) && !_M_future.unique())
        -: 1082:          _M_future->_M_break_promise(std::move(_M_storage));
        -: 1083:      }
        -: 1084:
        -: 1085:      // Assignment
        -: 1086:      promise&
        -: 1087:      operator=(promise&& __rhs) noexcept
        -: 1088:      {
        -: 1089:        promise(std::move(__rhs)).swap(*this);
        -: 1090:        return *this;
        -: 1091:      }
        -: 1092:
        -: 1093:      promise& operator=(const promise&) = delete;
        -: 1094:
        -: 1095:      void
        -: 1096:      swap(promise& __rhs) noexcept
        -: 1097:      {
        -: 1098:        _M_future.swap(__rhs._M_future);
        -: 1099:        _M_storage.swap(__rhs._M_storage);
        -: 1100:      }
        -: 1101:
        -: 1102:      // Retrieving the result
        -: 1103:      future<_Res>
        -: 1104:      get_future()
        -: 1105:      { return future<_Res>(_M_future); }
        -: 1106:
        -: 1107:      // Setting the result
        -: 1108:      void
        -: 1109:      set_value(const _Res& __r)
        -: 1110:      { _M_future->_M_set_result(_State::__setter(this, __r)); }
        -: 1111:
        -: 1112:      void
        -: 1113:      set_value(_Res&& __r)
        -: 1114:      { _M_future->_M_set_result(_State::__setter(this, std::move(__r))); }
        -: 1115:
        -: 1116:      void
        -: 1117:      set_exception(exception_ptr __p)
        -: 1118:      { _M_future->_M_set_result(_State::__setter(__p, this)); }
        -: 1119:
        -: 1120:      void
        -: 1121:      set_value_at_thread_exit(const _Res& __r)
        -: 1122:      {
        -: 1123:	_M_future->_M_set_delayed_result(_State::__setter(this, __r),
        -: 1124:					 _M_future);
        -: 1125:      }
        -: 1126:
        -: 1127:      void
        -: 1128:      set_value_at_thread_exit(_Res&& __r)
        -: 1129:      {
        -: 1130:	_M_future->_M_set_delayed_result(
        -: 1131:	    _State::__setter(this, std::move(__r)), _M_future);
        -: 1132:      }
        -: 1133:
        -: 1134:      void
        -: 1135:      set_exception_at_thread_exit(exception_ptr __p)
        -: 1136:      {
        -: 1137:	_M_future->_M_set_delayed_result(_State::__setter(__p, this),
        -: 1138:					 _M_future);
        -: 1139:      }
        -: 1140:    };
        -: 1141:
        -: 1142:  template<typename _Res>
        -: 1143:    inline void
        -: 1144:    swap(promise<_Res>& __x, promise<_Res>& __y) noexcept
        -: 1145:    { __x.swap(__y); }
        -: 1146:
        -: 1147:  template<typename _Res, typename _Alloc>
        -: 1148:    struct uses_allocator<promise<_Res>, _Alloc>
        -: 1149:    : public true_type { };
        -: 1150:
        -: 1151:
        -: 1152:  /// Partial specialization for promise<R&>
        -: 1153:  template<typename _Res>
        -: 1154:    class promise<_Res&>
        -: 1155:    {
        -: 1156:      typedef __future_base::_State_base	_State;
        -: 1157:      typedef __future_base::_Result<_Res&>	_Res_type;
        -: 1158:      typedef __future_base::_Ptr<_Res_type> 	_Ptr_type;
        -: 1159:      template<typename, typename> friend class _State::_Setter;
        -: 1160:      friend _State;
        -: 1161:
        -: 1162:      shared_ptr<_State>                        _M_future;
        -: 1163:      _Ptr_type                                 _M_storage;
        -: 1164:
        -: 1165:    public:
        -: 1166:      promise()
        -: 1167:      : _M_future(std::make_shared<_State>()),
        -: 1168:	_M_storage(new _Res_type())
        -: 1169:      { }
        -: 1170:
        -: 1171:      promise(promise&& __rhs) noexcept
        -: 1172:      : _M_future(std::move(__rhs._M_future)),
        -: 1173:	_M_storage(std::move(__rhs._M_storage))
        -: 1174:      { }
        -: 1175:
        -: 1176:      template<typename _Allocator>
        -: 1177:        promise(allocator_arg_t, const _Allocator& __a)
        -: 1178:        : _M_future(std::allocate_shared<_State>(__a)),
        -: 1179:	  _M_storage(__future_base::_S_allocate_result<_Res&>(__a))
        -: 1180:        { }
        -: 1181:
        -: 1182:      template<typename _Allocator>
        -: 1183:        promise(allocator_arg_t, const _Allocator&, promise&& __rhs)
        -: 1184:        : _M_future(std::move(__rhs._M_future)),
        -: 1185:	  _M_storage(std::move(__rhs._M_storage))
        -: 1186:        { }
        -: 1187:
        -: 1188:      promise(const promise&) = delete;
        -: 1189:
        -: 1190:      ~promise()
        -: 1191:      {
        -: 1192:        if (static_cast<bool>(_M_future) && !_M_future.unique())
        -: 1193:          _M_future->_M_break_promise(std::move(_M_storage));
        -: 1194:      }
        -: 1195:
        -: 1196:      // Assignment
        -: 1197:      promise&
        -: 1198:      operator=(promise&& __rhs) noexcept
        -: 1199:      {
        -: 1200:        promise(std::move(__rhs)).swap(*this);
        -: 1201:        return *this;
        -: 1202:      }
        -: 1203:
        -: 1204:      promise& operator=(const promise&) = delete;
        -: 1205:
        -: 1206:      void
        -: 1207:      swap(promise& __rhs) noexcept
        -: 1208:      {
        -: 1209:        _M_future.swap(__rhs._M_future);
        -: 1210:        _M_storage.swap(__rhs._M_storage);
        -: 1211:      }
        -: 1212:
        -: 1213:      // Retrieving the result
        -: 1214:      future<_Res&>
        -: 1215:      get_future()
        -: 1216:      { return future<_Res&>(_M_future); }
        -: 1217:
        -: 1218:      // Setting the result
        -: 1219:      void
        -: 1220:      set_value(_Res& __r)
        -: 1221:      { _M_future->_M_set_result(_State::__setter(this, __r)); }
        -: 1222:
        -: 1223:      void
        -: 1224:      set_exception(exception_ptr __p)
        -: 1225:      { _M_future->_M_set_result(_State::__setter(__p, this)); }
        -: 1226:
        -: 1227:      void
        -: 1228:      set_value_at_thread_exit(_Res& __r)
        -: 1229:      {
        -: 1230:	_M_future->_M_set_delayed_result(_State::__setter(this, __r),
        -: 1231:					 _M_future);
        -: 1232:      }
        -: 1233:
        -: 1234:      void
        -: 1235:      set_exception_at_thread_exit(exception_ptr __p)
        -: 1236:      {
        -: 1237:	_M_future->_M_set_delayed_result(_State::__setter(__p, this),
        -: 1238:					 _M_future);
        -: 1239:      }
        -: 1240:    };
        -: 1241:
        -: 1242:  /// Explicit specialization for promise<void>
        -: 1243:  template<>
        -: 1244:    class promise<void>
        -: 1245:    {
        -: 1246:      typedef __future_base::_State_base	_State;
        -: 1247:      typedef __future_base::_Result<void>	_Res_type;
        -: 1248:      typedef __future_base::_Ptr<_Res_type> 	_Ptr_type;
        -: 1249:      template<typename, typename> friend class _State::_Setter;
        -: 1250:      friend _State;
        -: 1251:
        -: 1252:      shared_ptr<_State>                        _M_future;
        -: 1253:      _Ptr_type                                 _M_storage;
        -: 1254:
        -: 1255:    public:
function _ZNSt7promiseIvEC2Ev called 0 returned 0% blocks executed 0%
    #####: 1256:      promise()
    #####: 1257:      : _M_future(std::make_shared<_State>()),
call    0 never executed
    #####: 1258:	_M_storage(new _Res_type())
call    0 never executed
call    1 never executed
    #####: 1259:      { }
        -: 1260:
        -: 1261:      promise(promise&& __rhs) noexcept
        -: 1262:      : _M_future(std::move(__rhs._M_future)),
        -: 1263:	_M_storage(std::move(__rhs._M_storage))
        -: 1264:      { }
        -: 1265:
        -: 1266:      template<typename _Allocator>
        -: 1267:        promise(allocator_arg_t, const _Allocator& __a)
        -: 1268:        : _M_future(std::allocate_shared<_State>(__a)),
        -: 1269:	  _M_storage(__future_base::_S_allocate_result<void>(__a))
        -: 1270:        { }
        -: 1271:
        -: 1272:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1273:      // 2095.  missing constructors needed for uses-allocator construction
        -: 1274:      template<typename _Allocator>
        -: 1275:        promise(allocator_arg_t, const _Allocator&, promise&& __rhs)
        -: 1276:        : _M_future(std::move(__rhs._M_future)),
        -: 1277:	  _M_storage(std::move(__rhs._M_storage))
        -: 1278:        { }
        -: 1279:
        -: 1280:      promise(const promise&) = delete;
        -: 1281:
function _ZNSt7promiseIvED2Ev called 0 returned 0% blocks executed 0%
    #####: 1282:      ~promise()
    #####: 1283:      {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1284:        if (static_cast<bool>(_M_future) && !_M_future.unique())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1285:          _M_future->_M_break_promise(std::move(_M_storage));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1286:      }
        -: 1287:
        -: 1288:      // Assignment
        -: 1289:      promise&
        -: 1290:      operator=(promise&& __rhs) noexcept
        -: 1291:      {
        -: 1292:        promise(std::move(__rhs)).swap(*this);
        -: 1293:        return *this;
        -: 1294:      }
        -: 1295:
        -: 1296:      promise& operator=(const promise&) = delete;
        -: 1297:
        -: 1298:      void
        -: 1299:      swap(promise& __rhs) noexcept
        -: 1300:      {
        -: 1301:        _M_future.swap(__rhs._M_future);
        -: 1302:        _M_storage.swap(__rhs._M_storage);
        -: 1303:      }
        -: 1304:
        -: 1305:      // Retrieving the result
        -: 1306:      future<void>
    #####: 1307:      get_future()
    #####: 1308:      { return future<void>(_M_future); }
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1309:
        -: 1310:      // Setting the result
        -: 1311:      void
function _ZNSt7promiseIvE9set_valueEv called 0 returned 0% blocks executed 0%
    #####: 1312:      set_value()
    #####: 1313:      { _M_future->_M_set_result(_State::__setter(this)); }
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1314:
        -: 1315:      void
        -: 1316:      set_exception(exception_ptr __p)
        -: 1317:      { _M_future->_M_set_result(_State::__setter(__p, this)); }
        -: 1318:
        -: 1319:      void
        -: 1320:      set_value_at_thread_exit()
        -: 1321:      { _M_future->_M_set_delayed_result(_State::__setter(this), _M_future); }
        -: 1322:
        -: 1323:      void
        -: 1324:      set_exception_at_thread_exit(exception_ptr __p)
        -: 1325:      {
        -: 1326:	_M_future->_M_set_delayed_result(_State::__setter(__p, this),
        -: 1327:					 _M_future);
        -: 1328:      }
        -: 1329:    };
        -: 1330:
        -: 1331:  template<typename _Ptr_type, typename _Fn, typename _Res>
        -: 1332:    struct __future_base::_Task_setter
        -: 1333:    {
        -: 1334:      // Invoke the function and provide the result to the caller.
        -: 1335:      _Ptr_type operator()() const
        -: 1336:      {
        -: 1337:	__try
        -: 1338:	  {
        -: 1339:	    (*_M_result)->_M_set((*_M_fn)());
        -: 1340:	  }
        -: 1341:	__catch(const __cxxabiv1::__forced_unwind&)
        -: 1342:	  {
        -: 1343:	    __throw_exception_again; // will cause broken_promise
        -: 1344:	  }
        -: 1345:	__catch(...)
        -: 1346:	  {
        -: 1347:	    (*_M_result)->_M_error = current_exception();
        -: 1348:	  }
        -: 1349:	return std::move(*_M_result);
        -: 1350:      }
        -: 1351:      _Ptr_type*	_M_result;
        -: 1352:      _Fn*		_M_fn;
        -: 1353:    };
        -: 1354:
        -: 1355:  template<typename _Ptr_type, typename _Fn>
        -: 1356:    struct __future_base::_Task_setter<_Ptr_type, _Fn, void>
        -: 1357:    {
        -: 1358:      _Ptr_type operator()() const
        -: 1359:      {
        -: 1360:	__try
        -: 1361:	  {
        -: 1362:	    (*_M_fn)();
        -: 1363:	  }
        -: 1364:	__catch(const __cxxabiv1::__forced_unwind&)
        -: 1365:	  {
        -: 1366:	    __throw_exception_again; // will cause broken_promise
        -: 1367:	  }
        -: 1368:	__catch(...)
        -: 1369:	  {
        -: 1370:	    (*_M_result)->_M_error = current_exception();
        -: 1371:	  }
        -: 1372:	return std::move(*_M_result);
        -: 1373:      }
        -: 1374:      _Ptr_type*	_M_result;
        -: 1375:      _Fn*		_M_fn;
        -: 1376:    };
        -: 1377:
        -: 1378:  // Holds storage for a packaged_task's result.
        -: 1379:  template<typename _Res, typename... _Args>
        -: 1380:    struct __future_base::_Task_state_base<_Res(_Args...)>
        -: 1381:    : __future_base::_State_base
        -: 1382:    {
        -: 1383:      typedef _Res _Res_type;
        -: 1384:
        -: 1385:      template<typename _Alloc>
        -: 1386:	_Task_state_base(const _Alloc& __a)
        -: 1387:	: _M_result(_S_allocate_result<_Res>(__a))
        -: 1388:	{ }
        -: 1389:
        -: 1390:      // Invoke the stored task and make the state ready.
        -: 1391:      virtual void
        -: 1392:      _M_run(_Args&&... __args) = 0;
        -: 1393:
        -: 1394:      // Invoke the stored task and make the state ready at thread exit.
        -: 1395:      virtual void
        -: 1396:      _M_run_delayed(_Args&&... __args, weak_ptr<_State_base>) = 0;
        -: 1397:
        -: 1398:      virtual shared_ptr<_Task_state_base>
        -: 1399:      _M_reset() = 0;
        -: 1400:
        -: 1401:      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;
        -: 1402:      _Ptr_type _M_result;
        -: 1403:    };
        -: 1404:
        -: 1405:  // Holds a packaged_task's stored task.
        -: 1406:  template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>
        -: 1407:    struct __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)> final
        -: 1408:    : __future_base::_Task_state_base<_Res(_Args...)>
        -: 1409:    {
        -: 1410:      template<typename _Fn2>
        -: 1411:	_Task_state(_Fn2&& __fn, const _Alloc& __a)
        -: 1412:	: _Task_state_base<_Res(_Args...)>(__a),
        -: 1413:	  _M_impl(std::forward<_Fn2>(__fn), __a)
        -: 1414:	{ }
        -: 1415:
        -: 1416:    private:
        -: 1417:      virtual void
        -: 1418:      _M_run(_Args&&... __args)
        -: 1419:      {
        -: 1420:	auto __boundfn = [&] () -> typename result_of<_Fn&(_Args&&...)>::type {
        -: 1421:	    return std::__invoke(_M_impl._M_fn, std::forward<_Args>(__args)...);
        -: 1422:	};
        -: 1423:	this->_M_set_result(_S_task_setter(this->_M_result, __boundfn));
        -: 1424:      }
        -: 1425:
        -: 1426:      virtual void
        -: 1427:      _M_run_delayed(_Args&&... __args, weak_ptr<_State_base> __self)
        -: 1428:      {
        -: 1429:	auto __boundfn = [&] () -> typename result_of<_Fn&(_Args&&...)>::type {
        -: 1430:	    return std::__invoke(_M_impl._M_fn, std::forward<_Args>(__args)...);
        -: 1431:	};
        -: 1432:	this->_M_set_delayed_result(_S_task_setter(this->_M_result, __boundfn),
        -: 1433:				    std::move(__self));
        -: 1434:      }
        -: 1435:
        -: 1436:      virtual shared_ptr<_Task_state_base<_Res(_Args...)>>
        -: 1437:      _M_reset();
        -: 1438:
        -: 1439:      struct _Impl : _Alloc
        -: 1440:      {
        -: 1441:	template<typename _Fn2>
        -: 1442:	  _Impl(_Fn2&& __fn, const _Alloc& __a)
        -: 1443:	  : _Alloc(__a), _M_fn(std::forward<_Fn2>(__fn)) { }
        -: 1444:	_Fn _M_fn;
        -: 1445:      } _M_impl;
        -: 1446:    };
        -: 1447:
        -: 1448:  template<typename _Signature, typename _Fn, typename _Alloc>
        -: 1449:    static shared_ptr<__future_base::_Task_state_base<_Signature>>
        -: 1450:    __create_task_state(_Fn&& __fn, const _Alloc& __a)
        -: 1451:    {
        -: 1452:      typedef typename decay<_Fn>::type _Fn2;
        -: 1453:      typedef __future_base::_Task_state<_Fn2, _Alloc, _Signature> _State;
        -: 1454:      return std::allocate_shared<_State>(__a, std::forward<_Fn>(__fn), __a);
        -: 1455:    }
        -: 1456:
        -: 1457:  template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>
        -: 1458:    shared_ptr<__future_base::_Task_state_base<_Res(_Args...)>>
        -: 1459:    __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)>::_M_reset()
        -: 1460:    {
        -: 1461:      return __create_task_state<_Res(_Args...)>(std::move(_M_impl._M_fn),
        -: 1462:						 static_cast<_Alloc&>(_M_impl));
        -: 1463:    }
        -: 1464:
        -: 1465:  /// packaged_task
        -: 1466:  template<typename _Res, typename... _ArgTypes>
        -: 1467:    class packaged_task<_Res(_ArgTypes...)>
        -: 1468:    {
        -: 1469:      typedef __future_base::_Task_state_base<_Res(_ArgTypes...)> _State_type;
        -: 1470:      shared_ptr<_State_type>                   _M_state;
        -: 1471:
        -: 1472:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1473:      // 3039. Unnecessary decay in thread and packaged_task
        -: 1474:      template<typename _Fn, typename _Fn2 = __remove_cvref_t<_Fn>>
        -: 1475:	using __not_same
        -: 1476:	  = typename enable_if<!is_same<packaged_task, _Fn2>::value>::type;
        -: 1477:
        -: 1478:    public:
        -: 1479:      // Construction and destruction
        -: 1480:      packaged_task() noexcept { }
        -: 1481:
        -: 1482:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1483:      // 2095.  missing constructors needed for uses-allocator construction
        -: 1484:      template<typename _Allocator>
        -: 1485:	packaged_task(allocator_arg_t, const _Allocator& __a) noexcept
        -: 1486:	{ }
        -: 1487:
        -: 1488:      template<typename _Fn, typename = __not_same<_Fn>>
        -: 1489:	explicit
        -: 1490:	packaged_task(_Fn&& __fn)
        -: 1491:	: packaged_task(allocator_arg, std::allocator<int>(),
        -: 1492:			std::forward<_Fn>(__fn))
        -: 1493:	{ }
        -: 1494:
        -: 1495:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -: 1496:      // 2097.  packaged_task constructors should be constrained
        -: 1497:      // 2407. [this constructor should not be] explicit
        -: 1498:      template<typename _Fn, typename _Alloc, typename = __not_same<_Fn>>
        -: 1499:	packaged_task(allocator_arg_t, const _Alloc& __a, _Fn&& __fn)
        -: 1500:	: _M_state(__create_task_state<_Res(_ArgTypes...)>(
        -: 1501:		   std::forward<_Fn>(__fn), __a))
        -: 1502:	{ }
        -: 1503:
        -: 1504:      ~packaged_task()
        -: 1505:      {
        -: 1506:        if (static_cast<bool>(_M_state) && !_M_state.unique())
        -: 1507:	  _M_state->_M_break_promise(std::move(_M_state->_M_result));
        -: 1508:      }
        -: 1509:
        -: 1510:      // No copy
        -: 1511:      packaged_task(const packaged_task&) = delete;
        -: 1512:      packaged_task& operator=(const packaged_task&) = delete;
        -: 1513:
        -: 1514:      template<typename _Allocator>
        -: 1515:	packaged_task(allocator_arg_t, const _Allocator&,
        -: 1516:		      const packaged_task&) = delete;
        -: 1517:
        -: 1518:      // Move support
        -: 1519:      packaged_task(packaged_task&& __other) noexcept
        -: 1520:      { this->swap(__other); }
        -: 1521:
        -: 1522:      template<typename _Allocator>
        -: 1523:	packaged_task(allocator_arg_t, const _Allocator&,
        -: 1524:		      packaged_task&& __other) noexcept
        -: 1525:	{ this->swap(__other); }
        -: 1526:
        -: 1527:      packaged_task& operator=(packaged_task&& __other) noexcept
        -: 1528:      {
        -: 1529:	packaged_task(std::move(__other)).swap(*this);
        -: 1530:	return *this;
        -: 1531:      }
        -: 1532:
        -: 1533:      void
        -: 1534:      swap(packaged_task& __other) noexcept
        -: 1535:      { _M_state.swap(__other._M_state); }
        -: 1536:
        -: 1537:      bool
        -: 1538:      valid() const noexcept
        -: 1539:      { return static_cast<bool>(_M_state); }
        -: 1540:
        -: 1541:      // Result retrieval
        -: 1542:      future<_Res>
        -: 1543:      get_future()
        -: 1544:      { return future<_Res>(_M_state); }
        -: 1545:
        -: 1546:      // Execution
        -: 1547:      void
        -: 1548:      operator()(_ArgTypes... __args)
        -: 1549:      {
        -: 1550:	__future_base::_State_base::_S_check(_M_state);
        -: 1551:	_M_state->_M_run(std::forward<_ArgTypes>(__args)...);
        -: 1552:      }
        -: 1553:
        -: 1554:      void
        -: 1555:      make_ready_at_thread_exit(_ArgTypes... __args)
        -: 1556:      {
        -: 1557:	__future_base::_State_base::_S_check(_M_state);
        -: 1558:	_M_state->_M_run_delayed(std::forward<_ArgTypes>(__args)..., _M_state);
        -: 1559:      }
        -: 1560:
        -: 1561:      void
        -: 1562:      reset()
        -: 1563:      {
        -: 1564:	__future_base::_State_base::_S_check(_M_state);
        -: 1565:	packaged_task __tmp;
        -: 1566:	__tmp._M_state = _M_state;
        -: 1567:	_M_state = _M_state->_M_reset();
        -: 1568:      }
        -: 1569:    };
        -: 1570:
        -: 1571:  /// swap
        -: 1572:  template<typename _Res, typename... _ArgTypes>
        -: 1573:    inline void
        -: 1574:    swap(packaged_task<_Res(_ArgTypes...)>& __x,
        -: 1575:	 packaged_task<_Res(_ArgTypes...)>& __y) noexcept
        -: 1576:    { __x.swap(__y); }
        -: 1577:
        -: 1578:  template<typename _Res, typename _Alloc>
        -: 1579:    struct uses_allocator<packaged_task<_Res>, _Alloc>
        -: 1580:    : public true_type { };
        -: 1581:
        -: 1582:
        -: 1583:  // Shared state created by std::async().
        -: 1584:  // Holds a deferred function and storage for its result.
        -: 1585:  template<typename _BoundFn, typename _Res>
        -: 1586:    class __future_base::_Deferred_state final
        -: 1587:    : public __future_base::_State_base
        -: 1588:    {
        -: 1589:    public:
        -: 1590:      explicit
        -: 1591:      _Deferred_state(_BoundFn&& __fn)
        -: 1592:      : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))
        -: 1593:      { }
        -: 1594:
        -: 1595:    private:
        -: 1596:      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;
        -: 1597:      _Ptr_type _M_result;
        -: 1598:      _BoundFn _M_fn;
        -: 1599:
        -: 1600:      // Run the deferred function.
        -: 1601:      virtual void
        -: 1602:      _M_complete_async()
        -: 1603:      {
        -: 1604:	// Multiple threads can call a waiting function on the future and
        -: 1605:	// reach this point at the same time. The call_once in _M_set_result
        -: 1606:	// ensures only the first one run the deferred function, stores the
        -: 1607:	// result in _M_result, swaps that with the base _M_result and makes
        -: 1608:	// the state ready. Tell _M_set_result to ignore failure so all later
        -: 1609:	// calls do nothing.
        -: 1610:        _M_set_result(_S_task_setter(_M_result, _M_fn), true);
        -: 1611:      }
        -: 1612:
        -: 1613:      // Caller should check whether the state is ready first, because this
        -: 1614:      // function will return true even after the deferred function has run.
        -: 1615:      virtual bool _M_is_deferred_future() const { return true; }
        -: 1616:    };
        -: 1617:
        -: 1618:  // Common functionality hoisted out of the _Async_state_impl template.
        -: 1619:  class __future_base::_Async_state_commonV2
        -: 1620:    : public __future_base::_State_base
        -: 1621:  {
        -: 1622:  protected:
        -: 1623:    ~_Async_state_commonV2() = default;
        -: 1624:
        -: 1625:    // Make waiting functions block until the thread completes, as if joined.
        -: 1626:    //
        -: 1627:    // This function is used by wait() to satisfy the first requirement below
        -: 1628:    // and by wait_for() / wait_until() to satisfy the second.
        -: 1629:    //
        -: 1630:    // [futures.async]:
        -: 1631:    //
        -: 1632:    // - a call to a waiting function on an asynchronous return object that
        -: 1633:    // shares the shared state created by this async call shall block until
        -: 1634:    // the associated thread has completed, as if joined, or else time out.
        -: 1635:    //
        -: 1636:    // - the associated thread completion synchronizes with the return from
        -: 1637:    // the first function that successfully detects the ready status of the
        -: 1638:    // shared state or with the return from the last function that releases
        -: 1639:    // the shared state, whichever happens first.
        -: 1640:    virtual void _M_complete_async() { _M_join(); }
        -: 1641:
        -: 1642:    void _M_join() { std::call_once(_M_once, &thread::join, &_M_thread); }
        -: 1643:
        -: 1644:    thread _M_thread;
        -: 1645:    once_flag _M_once;
        -: 1646:  };
        -: 1647:
        -: 1648:  // Shared state created by std::async().
        -: 1649:  // Starts a new thread that runs a function and makes the shared state ready.
        -: 1650:  template<typename _BoundFn, typename _Res>
        -: 1651:    class __future_base::_Async_state_impl final
        -: 1652:    : public __future_base::_Async_state_commonV2
        -: 1653:    {
        -: 1654:    public:
        -: 1655:      explicit
        -: 1656:      _Async_state_impl(_BoundFn&& __fn)
        -: 1657:      : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))
        -: 1658:      {
        -: 1659:	_M_thread = std::thread{ [this] {
        -: 1660:	    __try
        -: 1661:	      {
        -: 1662:		_M_set_result(_S_task_setter(_M_result, _M_fn));
        -: 1663:	      }
        -: 1664:	    __catch (const __cxxabiv1::__forced_unwind&)
        -: 1665:	      {
        -: 1666:		// make the shared state ready on thread cancellation
        -: 1667:		if (static_cast<bool>(_M_result))
        -: 1668:		  this->_M_break_promise(std::move(_M_result));
        -: 1669:		__throw_exception_again;
        -: 1670:	      }
        -: 1671:        } };
        -: 1672:      }
        -: 1673:
        -: 1674:      // Must not destroy _M_result and _M_fn until the thread finishes.
        -: 1675:      // Call join() directly rather than through _M_join() because no other
        -: 1676:      // thread can be referring to this state if it is being destroyed.
        -: 1677:      ~_Async_state_impl() { if (_M_thread.joinable()) _M_thread.join(); }
        -: 1678:
        -: 1679:    private:
        -: 1680:      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;
        -: 1681:      _Ptr_type _M_result;
        -: 1682:      _BoundFn _M_fn;
        -: 1683:    };
        -: 1684:
        -: 1685:  template<typename _BoundFn>
        -: 1686:    inline std::shared_ptr<__future_base::_State_base>
        -: 1687:    __future_base::_S_make_deferred_state(_BoundFn&& __fn)
        -: 1688:    {
        -: 1689:      typedef typename remove_reference<_BoundFn>::type __fn_type;
        -: 1690:      typedef _Deferred_state<__fn_type> __state_type;
        -: 1691:      return std::make_shared<__state_type>(std::move(__fn));
        -: 1692:    }
        -: 1693:
        -: 1694:  template<typename _BoundFn>
        -: 1695:    inline std::shared_ptr<__future_base::_State_base>
        -: 1696:    __future_base::_S_make_async_state(_BoundFn&& __fn)
        -: 1697:    {
        -: 1698:      typedef typename remove_reference<_BoundFn>::type __fn_type;
        -: 1699:      typedef _Async_state_impl<__fn_type> __state_type;
        -: 1700:      return std::make_shared<__state_type>(std::move(__fn));
        -: 1701:    }
        -: 1702:
        -: 1703:
        -: 1704:  /// async
        -: 1705:  template<typename _Fn, typename... _Args>
        -: 1706:    _GLIBCXX_NODISCARD future<__async_result_of<_Fn, _Args...>>
        -: 1707:    async(launch __policy, _Fn&& __fn, _Args&&... __args)
        -: 1708:    {
        -: 1709:      std::shared_ptr<__future_base::_State_base> __state;
        -: 1710:      if ((__policy & launch::async) == launch::async)
        -: 1711:	{
        -: 1712:	  __try
        -: 1713:	    {
        -: 1714:	      __state = __future_base::_S_make_async_state(
        -: 1715:		  std::thread::__make_invoker(std::forward<_Fn>(__fn),
        -: 1716:					      std::forward<_Args>(__args)...)
        -: 1717:		  );
        -: 1718:	    }
        -: 1719:#if __cpp_exceptions
        -: 1720:	  catch(const system_error& __e)
        -: 1721:	    {
        -: 1722:	      if (__e.code() != errc::resource_unavailable_try_again
        -: 1723:		  || (__policy & launch::deferred) != launch::deferred)
        -: 1724:		throw;
        -: 1725:	    }
        -: 1726:#endif
        -: 1727:	}
        -: 1728:      if (!__state)
        -: 1729:	{
        -: 1730:	  __state = __future_base::_S_make_deferred_state(
        -: 1731:	      std::thread::__make_invoker(std::forward<_Fn>(__fn),
        -: 1732:					  std::forward<_Args>(__args)...));
        -: 1733:	}
        -: 1734:      return future<__async_result_of<_Fn, _Args...>>(__state);
        -: 1735:    }
        -: 1736:
        -: 1737:  /// async, potential overload
        -: 1738:  template<typename _Fn, typename... _Args>
        -: 1739:    _GLIBCXX_NODISCARD inline future<__async_result_of<_Fn, _Args...>>
        -: 1740:    async(_Fn&& __fn, _Args&&... __args)
        -: 1741:    {
        -: 1742:      return std::async(launch::async|launch::deferred,
        -: 1743:			std::forward<_Fn>(__fn),
        -: 1744:			std::forward<_Args>(__args)...);
        -: 1745:    }
        -: 1746:
        -: 1747:#endif // _GLIBCXX_ASYNC_ABI_COMPAT
        -: 1748:#endif // _GLIBCXX_HAS_GTHREADS
        -: 1749:
        -: 1750:  /// @} group futures
        -: 1751:_GLIBCXX_END_NAMESPACE_VERSION
        -: 1752:} // namespace
        -: 1753:
        -: 1754:#endif // C++11
        -: 1755:
        -: 1756:#endif // _GLIBCXX_FUTURE
