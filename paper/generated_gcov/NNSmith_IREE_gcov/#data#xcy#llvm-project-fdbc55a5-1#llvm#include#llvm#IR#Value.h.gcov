        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/llvm/include/llvm/IR/Value.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:325580
        -:    1://===- llvm/Value.h - Definition of the Value class -------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file declares the Value class.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef LLVM_IR_VALUE_H
        -:   14:#define LLVM_IR_VALUE_H
        -:   15:
        -:   16:#include "llvm-c/Types.h"
        -:   17:#include "llvm/ADT/STLExtras.h"
        -:   18:#include "llvm/ADT/StringRef.h"
        -:   19:#include "llvm/ADT/iterator_range.h"
        -:   20:#include "llvm/IR/Use.h"
        -:   21:#include "llvm/Support/Alignment.h"
        -:   22:#include "llvm/Support/CBindingWrapping.h"
        -:   23:#include "llvm/Support/Casting.h"
        -:   24:#include <cassert>
        -:   25:#include <iterator>
        -:   26:#include <memory>
        -:   27:
        -:   28:namespace llvm {
        -:   29:
        -:   30:class APInt;
        -:   31:class Argument;
        -:   32:class BasicBlock;
        -:   33:class Constant;
        -:   34:class ConstantData;
        -:   35:class ConstantAggregate;
        -:   36:class DataLayout;
        -:   37:class Function;
        -:   38:class GlobalAlias;
        -:   39:class GlobalIFunc;
        -:   40:class GlobalObject;
        -:   41:class GlobalValue;
        -:   42:class GlobalVariable;
        -:   43:class InlineAsm;
        -:   44:class Instruction;
        -:   45:class LLVMContext;
        -:   46:class MDNode;
        -:   47:class Module;
        -:   48:class ModuleSlotTracker;
        -:   49:class raw_ostream;
        -:   50:template<typename ValueTy> class StringMapEntry;
        -:   51:class Twine;
        -:   52:class Type;
        -:   53:class User;
        -:   54:
        -:   55:using ValueName = StringMapEntry<Value *>;
        -:   56:
        -:   57://===----------------------------------------------------------------------===//
        -:   58://                                 Value Class
        -:   59://===----------------------------------------------------------------------===//
        -:   60:
        -:   61:/// LLVM Value Representation
        -:   62:///
        -:   63:/// This is a very important LLVM class. It is the base class of all values
        -:   64:/// computed by a program that may be used as operands to other values. Value is
        -:   65:/// the super class of other important classes such as Instruction and Function.
        -:   66:/// All Values have a Type. Type is not a subclass of Value. Some values can
        -:   67:/// have a name and they belong to some Module.  Setting the name on the Value
        -:   68:/// automatically updates the module's symbol table.
        -:   69:///
        -:   70:/// Every value has a "use list" that keeps track of which other Values are
        -:   71:/// using this Value.  A Value can also have an arbitrary number of ValueHandle
        -:   72:/// objects that watch it and listen to RAUW and Destroy events.  See
        -:   73:/// llvm/IR/ValueHandle.h for details.
        -:   74:class Value {
        -:   75:  Type *VTy;
        -:   76:  Use *UseList;
        -:   77:
        -:   78:  friend class ValueAsMetadata; // Allow access to IsUsedByMD.
        -:   79:  friend class ValueHandleBase;
        -:   80:
        -:   81:  const unsigned char SubclassID;   // Subclass identifier (for isa/dyn_cast)
        -:   82:  unsigned char HasValueHandle : 1; // Has a ValueHandle pointing to this?
        -:   83:
        -:   84:protected:
        -:   85:  /// Hold subclass data that can be dropped.
        -:   86:  ///
        -:   87:  /// This member is similar to SubclassData, however it is for holding
        -:   88:  /// information which may be used to aid optimization, but which may be
        -:   89:  /// cleared to zero without affecting conservative interpretation.
        -:   90:  unsigned char SubclassOptionalData : 7;
        -:   91:
        -:   92:private:
        -:   93:  /// Hold arbitrary subclass data.
        -:   94:  ///
        -:   95:  /// This member is defined by this class, but is not used for anything.
        -:   96:  /// Subclasses can use it to hold whatever state they find useful.  This
        -:   97:  /// field is initialized to zero by the ctor.
        -:   98:  unsigned short SubclassData;
        -:   99:
        -:  100:protected:
        -:  101:  /// The number of operands in the subclass.
        -:  102:  ///
        -:  103:  /// This member is defined by this class, but not used for anything.
        -:  104:  /// Subclasses can use it to store their number of operands, if they have
        -:  105:  /// any.
        -:  106:  ///
        -:  107:  /// This is stored here to save space in User on 64-bit hosts.  Since most
        -:  108:  /// instances of Value have operands, 32-bit hosts aren't significantly
        -:  109:  /// affected.
        -:  110:  ///
        -:  111:  /// Note, this should *NOT* be used directly by any class other than User.
        -:  112:  /// User uses this value to find the Use list.
        -:  113:  enum : unsigned { NumUserOperandsBits = 27 };
        -:  114:  unsigned NumUserOperands : NumUserOperandsBits;
        -:  115:
        -:  116:  // Use the same type as the bitfield above so that MSVC will pack them.
        -:  117:  unsigned IsUsedByMD : 1;
        -:  118:  unsigned HasName : 1;
        -:  119:  unsigned HasMetadata : 1; // Has metadata attached to this?
        -:  120:  unsigned HasHungOffUses : 1;
        -:  121:  unsigned HasDescriptor : 1;
        -:  122:
        -:  123:private:
        -:  124:  template <typename UseT> // UseT == 'Use' or 'const Use'
        -:  125:  class use_iterator_impl {
        -:  126:    friend class Value;
        -:  127:
        -:  128:    UseT *U;
        -:  129:
        -:  130:    explicit use_iterator_impl(UseT *u) : U(u) {}
        -:  131:
        -:  132:  public:
        -:  133:    using iterator_category = std::forward_iterator_tag;
        -:  134:    using value_type = UseT *;
        -:  135:    using difference_type = std::ptrdiff_t;
        -:  136:    using pointer = value_type *;
        -:  137:    using reference = value_type &;
        -:  138:
        -:  139:    use_iterator_impl() : U() {}
        -:  140:
        -:  141:    bool operator==(const use_iterator_impl &x) const { return U == x.U; }
        -:  142:    bool operator!=(const use_iterator_impl &x) const { return !operator==(x); }
        -:  143:
        -:  144:    use_iterator_impl &operator++() { // Preincrement
        -:  145:      assert(U && "Cannot increment end iterator!");
        -:  146:      U = U->getNext();
        -:  147:      return *this;
        -:  148:    }
        -:  149:
        -:  150:    use_iterator_impl operator++(int) { // Postincrement
        -:  151:      auto tmp = *this;
        -:  152:      ++*this;
        -:  153:      return tmp;
        -:  154:    }
        -:  155:
        -:  156:    UseT &operator*() const {
        -:  157:      assert(U && "Cannot dereference end iterator!");
        -:  158:      return *U;
        -:  159:    }
        -:  160:
        -:  161:    UseT *operator->() const { return &operator*(); }
        -:  162:
        -:  163:    operator use_iterator_impl<const UseT>() const {
        -:  164:      return use_iterator_impl<const UseT>(U);
        -:  165:    }
        -:  166:  };
        -:  167:
        -:  168:  template <typename UserTy> // UserTy == 'User' or 'const User'
        -:  169:  class user_iterator_impl {
        -:  170:    use_iterator_impl<Use> UI;
        -:  171:    explicit user_iterator_impl(Use *U) : UI(U) {}
        -:  172:    friend class Value;
        -:  173:
        -:  174:  public:
        -:  175:    using iterator_category = std::forward_iterator_tag;
        -:  176:    using value_type = UserTy *;
        -:  177:    using difference_type = std::ptrdiff_t;
        -:  178:    using pointer = value_type *;
        -:  179:    using reference = value_type &;
        -:  180:
        -:  181:    user_iterator_impl() = default;
        -:  182:
        -:  183:    bool operator==(const user_iterator_impl &x) const { return UI == x.UI; }
        -:  184:    bool operator!=(const user_iterator_impl &x) const { return !operator==(x); }
        -:  185:
        -:  186:    /// Returns true if this iterator is equal to user_end() on the value.
        -:  187:    bool atEnd() const { return *this == user_iterator_impl(); }
        -:  188:
        -:  189:    user_iterator_impl &operator++() { // Preincrement
        -:  190:      ++UI;
        -:  191:      return *this;
        -:  192:    }
        -:  193:
        -:  194:    user_iterator_impl operator++(int) { // Postincrement
        -:  195:      auto tmp = *this;
        -:  196:      ++*this;
        -:  197:      return tmp;
        -:  198:    }
        -:  199:
        -:  200:    // Retrieve a pointer to the current User.
        -:  201:    UserTy *operator*() const {
        -:  202:      return UI->getUser();
        -:  203:    }
        -:  204:
        -:  205:    UserTy *operator->() const { return operator*(); }
        -:  206:
        -:  207:    operator user_iterator_impl<const UserTy>() const {
        -:  208:      return user_iterator_impl<const UserTy>(*UI);
        -:  209:    }
        -:  210:
        -:  211:    Use &getUse() const { return *UI; }
        -:  212:  };
        -:  213:
        -:  214:protected:
        -:  215:  Value(Type *Ty, unsigned scid);
        -:  216:
        -:  217:  /// Value's destructor should be virtual by design, but that would require
        -:  218:  /// that Value and all of its subclasses have a vtable that effectively
        -:  219:  /// duplicates the information in the value ID. As a size optimization, the
        -:  220:  /// destructor has been protected, and the caller should manually call
        -:  221:  /// deleteValue.
        -:  222:  ~Value(); // Use deleteValue() to delete a generic Value.
        -:  223:
        -:  224:public:
        -:  225:  Value(const Value &) = delete;
        -:  226:  Value &operator=(const Value &) = delete;
        -:  227:
        -:  228:  /// Delete a pointer to a generic Value.
        -:  229:  void deleteValue();
        -:  230:
        -:  231:  /// Support for debugging, callable in GDB: V->dump()
        -:  232:  void dump() const;
        -:  233:
        -:  234:  /// Implement operator<< on Value.
        -:  235:  /// @{
        -:  236:  void print(raw_ostream &O, bool IsForDebug = false) const;
        -:  237:  void print(raw_ostream &O, ModuleSlotTracker &MST,
        -:  238:             bool IsForDebug = false) const;
        -:  239:  /// @}
        -:  240:
        -:  241:  /// Print the name of this Value out to the specified raw_ostream.
        -:  242:  ///
        -:  243:  /// This is useful when you just want to print 'int %reg126', not the
        -:  244:  /// instruction that generated it. If you specify a Module for context, then
        -:  245:  /// even constanst get pretty-printed; for example, the type of a null
        -:  246:  /// pointer is printed symbolically.
        -:  247:  /// @{
        -:  248:  void printAsOperand(raw_ostream &O, bool PrintType = true,
        -:  249:                      const Module *M = nullptr) const;
        -:  250:  void printAsOperand(raw_ostream &O, bool PrintType,
        -:  251:                      ModuleSlotTracker &MST) const;
        -:  252:  /// @}
        -:  253:
        -:  254:  /// All values are typed, get the type of this value.
    #####:  255:  Type *getType() const { return VTy; }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
call   19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
        -:  256:
        -:  257:  /// All values hold a context through their type.
        -:  258:  LLVMContext &getContext() const;
        -:  259:
        -:  260:  // All values can potentially be named.
        -:  261:  bool hasName() const { return HasName; }
        -:  262:  ValueName *getValueName() const;
        -:  263:  void setValueName(ValueName *VN);
        -:  264:
        -:  265:private:
        -:  266:  void destroyValueName();
        -:  267:  enum class ReplaceMetadataUses { No, Yes };
        -:  268:  void doRAUW(Value *New, ReplaceMetadataUses);
        -:  269:  void setNameImpl(const Twine &Name);
        -:  270:
        -:  271:public:
        -:  272:  /// Return a constant reference to the value's name.
        -:  273:  ///
        -:  274:  /// This guaranteed to return the same reference as long as the value is not
        -:  275:  /// modified.  If the value has a name, this does a hashtable lookup, so it's
        -:  276:  /// not free.
        -:  277:  StringRef getName() const;
        -:  278:
        -:  279:  /// Change the name of the value.
        -:  280:  ///
        -:  281:  /// Choose a new unique name if the provided name is taken.
        -:  282:  ///
        -:  283:  /// \param Name The new name; or "" if the value's name should be removed.
        -:  284:  void setName(const Twine &Name);
        -:  285:
        -:  286:  /// Transfer the name from V to this value.
        -:  287:  ///
        -:  288:  /// After taking V's name, sets V's name to empty.
        -:  289:  ///
        -:  290:  /// \note It is an error to call V->takeName(V).
        -:  291:  void takeName(Value *V);
        -:  292:
        -:  293:#ifndef NDEBUG
        -:  294:  std::string getNameOrAsOperand() const;
        -:  295:#endif
        -:  296:
        -:  297:  /// Change all uses of this to point to a new Value.
        -:  298:  ///
        -:  299:  /// Go through the uses list for this definition and make each use point to
        -:  300:  /// "V" instead of "this".  After this completes, 'this's use list is
        -:  301:  /// guaranteed to be empty.
        -:  302:  void replaceAllUsesWith(Value *V);
        -:  303:
        -:  304:  /// Change non-metadata uses of this to point to a new Value.
        -:  305:  ///
        -:  306:  /// Go through the uses list for this definition and make each use point to
        -:  307:  /// "V" instead of "this". This function skips metadata entries in the list.
        -:  308:  void replaceNonMetadataUsesWith(Value *V);
        -:  309:
        -:  310:  /// Go through the uses list for this definition and make each use point
        -:  311:  /// to "V" if the callback ShouldReplace returns true for the given Use.
        -:  312:  /// Unlike replaceAllUsesWith() this function does not support basic block
        -:  313:  /// values.
        -:  314:  void replaceUsesWithIf(Value *New,
        -:  315:                         llvm::function_ref<bool(Use &U)> ShouldReplace);
        -:  316:
        -:  317:  /// replaceUsesOutsideBlock - Go through the uses list for this definition and
        -:  318:  /// make each use point to "V" instead of "this" when the use is outside the
        -:  319:  /// block. 'This's use list is expected to have at least one element.
        -:  320:  /// Unlike replaceAllUsesWith() this function does not support basic block
        -:  321:  /// values.
        -:  322:  void replaceUsesOutsideBlock(Value *V, BasicBlock *BB);
        -:  323:
        -:  324:  //----------------------------------------------------------------------
        -:  325:  // Methods for handling the chain of uses of this Value.
        -:  326:  //
        -:  327:  // Materializing a function can introduce new uses, so these methods come in
        -:  328:  // two variants:
        -:  329:  // The methods that start with materialized_ check the uses that are
        -:  330:  // currently known given which functions are materialized. Be very careful
        -:  331:  // when using them since you might not get all uses.
        -:  332:  // The methods that don't start with materialized_ assert that modules is
        -:  333:  // fully materialized.
        -:  334:  void assertModuleIsMaterializedImpl() const;
        -:  335:  // This indirection exists so we can keep assertModuleIsMaterializedImpl()
        -:  336:  // around in release builds of Value.cpp to be linked with other code built
        -:  337:  // in debug mode. But this avoids calling it in any of the release built code.
        -:  338:  void assertModuleIsMaterialized() const {
        -:  339:#ifndef NDEBUG
        -:  340:    assertModuleIsMaterializedImpl();
        -:  341:#endif
        -:  342:  }
        -:  343:
        -:  344:  bool use_empty() const {
        -:  345:    assertModuleIsMaterialized();
        -:  346:    return UseList == nullptr;
        -:  347:  }
        -:  348:
        -:  349:  bool materialized_use_empty() const {
        -:  350:    return UseList == nullptr;
        -:  351:  }
        -:  352:
        -:  353:  using use_iterator = use_iterator_impl<Use>;
        -:  354:  using const_use_iterator = use_iterator_impl<const Use>;
        -:  355:
        -:  356:  use_iterator materialized_use_begin() { return use_iterator(UseList); }
        -:  357:  const_use_iterator materialized_use_begin() const {
        -:  358:    return const_use_iterator(UseList);
        -:  359:  }
        -:  360:  use_iterator use_begin() {
        -:  361:    assertModuleIsMaterialized();
        -:  362:    return materialized_use_begin();
        -:  363:  }
        -:  364:  const_use_iterator use_begin() const {
        -:  365:    assertModuleIsMaterialized();
        -:  366:    return materialized_use_begin();
        -:  367:  }
        -:  368:  use_iterator use_end() { return use_iterator(); }
        -:  369:  const_use_iterator use_end() const { return const_use_iterator(); }
        -:  370:  iterator_range<use_iterator> materialized_uses() {
        -:  371:    return make_range(materialized_use_begin(), use_end());
        -:  372:  }
        -:  373:  iterator_range<const_use_iterator> materialized_uses() const {
        -:  374:    return make_range(materialized_use_begin(), use_end());
        -:  375:  }
        -:  376:  iterator_range<use_iterator> uses() {
        -:  377:    assertModuleIsMaterialized();
        -:  378:    return materialized_uses();
        -:  379:  }
        -:  380:  iterator_range<const_use_iterator> uses() const {
        -:  381:    assertModuleIsMaterialized();
        -:  382:    return materialized_uses();
        -:  383:  }
        -:  384:
        -:  385:  bool user_empty() const {
        -:  386:    assertModuleIsMaterialized();
        -:  387:    return UseList == nullptr;
        -:  388:  }
        -:  389:
        -:  390:  using user_iterator = user_iterator_impl<User>;
        -:  391:  using const_user_iterator = user_iterator_impl<const User>;
        -:  392:
        -:  393:  user_iterator materialized_user_begin() { return user_iterator(UseList); }
        -:  394:  const_user_iterator materialized_user_begin() const {
        -:  395:    return const_user_iterator(UseList);
        -:  396:  }
        -:  397:  user_iterator user_begin() {
        -:  398:    assertModuleIsMaterialized();
        -:  399:    return materialized_user_begin();
        -:  400:  }
        -:  401:  const_user_iterator user_begin() const {
        -:  402:    assertModuleIsMaterialized();
        -:  403:    return materialized_user_begin();
        -:  404:  }
        -:  405:  user_iterator user_end() { return user_iterator(); }
        -:  406:  const_user_iterator user_end() const { return const_user_iterator(); }
        -:  407:  User *user_back() {
        -:  408:    assertModuleIsMaterialized();
        -:  409:    return *materialized_user_begin();
        -:  410:  }
        -:  411:  const User *user_back() const {
        -:  412:    assertModuleIsMaterialized();
        -:  413:    return *materialized_user_begin();
        -:  414:  }
        -:  415:  iterator_range<user_iterator> materialized_users() {
        -:  416:    return make_range(materialized_user_begin(), user_end());
        -:  417:  }
        -:  418:  iterator_range<const_user_iterator> materialized_users() const {
        -:  419:    return make_range(materialized_user_begin(), user_end());
        -:  420:  }
        -:  421:  iterator_range<user_iterator> users() {
        -:  422:    assertModuleIsMaterialized();
        -:  423:    return materialized_users();
        -:  424:  }
        -:  425:  iterator_range<const_user_iterator> users() const {
        -:  426:    assertModuleIsMaterialized();
        -:  427:    return materialized_users();
        -:  428:  }
        -:  429:
        -:  430:  /// Return true if there is exactly one use of this value.
        -:  431:  ///
        -:  432:  /// This is specialized because it is a common request and does not require
        -:  433:  /// traversing the whole use list.
        -:  434:  bool hasOneUse() const { return hasSingleElement(uses()); }
        -:  435:
        -:  436:  /// Return true if this Value has exactly N uses.
        -:  437:  bool hasNUses(unsigned N) const;
        -:  438:
        -:  439:  /// Return true if this value has N uses or more.
        -:  440:  ///
        -:  441:  /// This is logically equivalent to getNumUses() >= N.
        -:  442:  bool hasNUsesOrMore(unsigned N) const;
        -:  443:
        -:  444:  /// Return true if there is exactly one user of this value.
        -:  445:  ///
        -:  446:  /// Note that this is not the same as "has one use". If a value has one use,
        -:  447:  /// then there certainly is a single user. But if value has several uses,
        -:  448:  /// it is possible that all uses are in a single user, or not.
        -:  449:  ///
        -:  450:  /// This check is potentially costly, since it requires traversing,
        -:  451:  /// in the worst case, the whole use list of a value.
        -:  452:  bool hasOneUser() const;
        -:  453:
        -:  454:  /// Return true if there is exactly one use of this value that cannot be
        -:  455:  /// dropped.
        -:  456:  Use *getSingleUndroppableUse();
        -:  457:  const Use *getSingleUndroppableUse() const {
        -:  458:    return const_cast<Value *>(this)->getSingleUndroppableUse();
        -:  459:  }
        -:  460:
        -:  461:  /// Return true if there is exactly one unique user of this value that cannot be
        -:  462:  /// dropped (that user can have multiple uses of this value).
        -:  463:  User *getUniqueUndroppableUser();
        -:  464:  const User *getUniqueUndroppableUser() const {
        -:  465:    return const_cast<Value *>(this)->getUniqueUndroppableUser();
        -:  466:  }
        -:  467:
        -:  468:  /// Return true if there this value.
        -:  469:  ///
        -:  470:  /// This is specialized because it is a common request and does not require
        -:  471:  /// traversing the whole use list.
        -:  472:  bool hasNUndroppableUses(unsigned N) const;
        -:  473:
        -:  474:  /// Return true if this value has N uses or more.
        -:  475:  ///
        -:  476:  /// This is logically equivalent to getNumUses() >= N.
        -:  477:  bool hasNUndroppableUsesOrMore(unsigned N) const;
        -:  478:
        -:  479:  /// Remove every uses that can safely be removed.
        -:  480:  ///
        -:  481:  /// This will remove for example uses in llvm.assume.
        -:  482:  /// This should be used when performing want to perform a tranformation but
        -:  483:  /// some Droppable uses pervent it.
        -:  484:  /// This function optionally takes a filter to only remove some droppable
        -:  485:  /// uses.
        -:  486:  void dropDroppableUses(llvm::function_ref<bool(const Use *)> ShouldDrop =
        -:  487:                             [](const Use *) { return true; });
        -:  488:
        -:  489:  /// Remove every use of this value in \p User that can safely be removed.
        -:  490:  void dropDroppableUsesIn(User &Usr);
        -:  491:
        -:  492:  /// Remove the droppable use \p U.
        -:  493:  static void dropDroppableUse(Use &U);
        -:  494:
        -:  495:  /// Check if this value is used in the specified basic block.
        -:  496:  bool isUsedInBasicBlock(const BasicBlock *BB) const;
        -:  497:
        -:  498:  /// This method computes the number of uses of this Value.
        -:  499:  ///
        -:  500:  /// This is a linear time operation.  Use hasOneUse, hasNUses, or
        -:  501:  /// hasNUsesOrMore to check for specific values.
        -:  502:  unsigned getNumUses() const;
        -:  503:
        -:  504:  /// This method should only be used by the Use class.
    #####:  505:  void addUse(Use &U) { U.addToList(&UseList); }
        -:  506:
        -:  507:  /// Concrete subclass of this.
        -:  508:  ///
        -:  509:  /// An enumeration for keeping track of the concrete subclass of Value that
        -:  510:  /// is actually instantiated. Values of this enumeration are kept in the
        -:  511:  /// Value classes SubclassID field. They are used for concrete type
        -:  512:  /// identification.
        -:  513:  enum ValueTy {
        -:  514:#define HANDLE_VALUE(Name) Name##Val,
        -:  515:#include "llvm/IR/Value.def"
        -:  516:
        -:  517:    // Markers:
        -:  518:#define HANDLE_CONSTANT_MARKER(Marker, Constant) Marker = Constant##Val,
        -:  519:#include "llvm/IR/Value.def"
        -:  520:  };
        -:  521:
        -:  522:  /// Return an ID for the concrete type of this object.
        -:  523:  ///
        -:  524:  /// This is used to implement the classof checks.  This should not be used
        -:  525:  /// for any other purpose, as the values may change as LLVM evolves.  Also,
        -:  526:  /// note that for instructions, the Instruction's opcode is added to
        -:  527:  /// InstructionVal. So this means three things:
        -:  528:  /// # there is no value with code InstructionVal (no opcode==0).
        -:  529:  /// # there are more possible values for the value type than in ValueTy enum.
        -:  530:  /// # the InstructionVal enumerator must be the highest valued enumerator in
        -:  531:  ///   the ValueTy enum.
    #####:  532:  unsigned getValueID() const {
    #####:  533:    return SubclassID;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  534:  }
        -:  535:
        -:  536:  /// Return the raw optional flags value contained in this value.
        -:  537:  ///
        -:  538:  /// This should only be used when testing two Values for equivalence.
        -:  539:  unsigned getRawSubclassOptionalData() const {
        -:  540:    return SubclassOptionalData;
        -:  541:  }
        -:  542:
        -:  543:  /// Clear the optional flags contained in this value.
        -:  544:  void clearSubclassOptionalData() {
        -:  545:    SubclassOptionalData = 0;
        -:  546:  }
        -:  547:
        -:  548:  /// Check the optional flags for equality.
        -:  549:  bool hasSameSubclassOptionalData(const Value *V) const {
        -:  550:    return SubclassOptionalData == V->SubclassOptionalData;
        -:  551:  }
        -:  552:
        -:  553:  /// Return true if there is a value handle associated with this value.
        -:  554:  bool hasValueHandle() const { return HasValueHandle; }
        -:  555:
        -:  556:  /// Return true if there is metadata referencing this value.
        -:  557:  bool isUsedByMetadata() const { return IsUsedByMD; }
        -:  558:
        -:  559:  // Return true if this value is only transitively referenced by metadata.
        -:  560:  bool isTransitiveUsedByMetadataOnly() const;
        -:  561:
        -:  562:protected:
        -:  563:  /// Get the current metadata attachments for the given kind, if any.
        -:  564:  ///
        -:  565:  /// These functions require that the value have at most a single attachment
        -:  566:  /// of the given kind, and return \c nullptr if such an attachment is missing.
        -:  567:  /// @{
        -:  568:  MDNode *getMetadata(unsigned KindID) const;
        -:  569:  MDNode *getMetadata(StringRef Kind) const;
        -:  570:  /// @}
        -:  571:
        -:  572:  /// Appends all attachments with the given ID to \c MDs in insertion order.
        -:  573:  /// If the Value has no attachments with the given ID, or if ID is invalid,
        -:  574:  /// leaves MDs unchanged.
        -:  575:  /// @{
        -:  576:  void getMetadata(unsigned KindID, SmallVectorImpl<MDNode *> &MDs) const;
        -:  577:  void getMetadata(StringRef Kind, SmallVectorImpl<MDNode *> &MDs) const;
        -:  578:  /// @}
        -:  579:
        -:  580:  /// Appends all metadata attached to this value to \c MDs, sorting by
        -:  581:  /// KindID. The first element of each pair returned is the KindID, the second
        -:  582:  /// element is the metadata value. Attachments with the same ID appear in
        -:  583:  /// insertion order.
        -:  584:  void
        -:  585:  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const;
        -:  586:
        -:  587:  /// Return true if this value has any metadata attached to it.
        -:  588:  bool hasMetadata() const { return (bool)HasMetadata; }
        -:  589:
        -:  590:  /// Return true if this value has the given type of metadata attached.
        -:  591:  /// @{
        -:  592:  bool hasMetadata(unsigned KindID) const {
        -:  593:    return getMetadata(KindID) != nullptr;
        -:  594:  }
        -:  595:  bool hasMetadata(StringRef Kind) const {
        -:  596:    return getMetadata(Kind) != nullptr;
        -:  597:  }
        -:  598:  /// @}
        -:  599:
        -:  600:  /// Set a particular kind of metadata attachment.
        -:  601:  ///
        -:  602:  /// Sets the given attachment to \c MD, erasing it if \c MD is \c nullptr or
        -:  603:  /// replacing it if it already exists.
        -:  604:  /// @{
        -:  605:  void setMetadata(unsigned KindID, MDNode *Node);
        -:  606:  void setMetadata(StringRef Kind, MDNode *Node);
        -:  607:  /// @}
        -:  608:
        -:  609:  /// Add a metadata attachment.
        -:  610:  /// @{
        -:  611:  void addMetadata(unsigned KindID, MDNode &MD);
        -:  612:  void addMetadata(StringRef Kind, MDNode &MD);
        -:  613:  /// @}
        -:  614:
        -:  615:  /// Erase all metadata attachments with the given kind.
        -:  616:  ///
        -:  617:  /// \returns true if any metadata was removed.
        -:  618:  bool eraseMetadata(unsigned KindID);
        -:  619:
        -:  620:  /// Erase all metadata attached to this Value.
        -:  621:  void clearMetadata();
        -:  622:
        -:  623:public:
        -:  624:  /// Return true if this value is a swifterror value.
        -:  625:  ///
        -:  626:  /// swifterror values can be either a function argument or an alloca with a
        -:  627:  /// swifterror attribute.
        -:  628:  bool isSwiftError() const;
        -:  629:
        -:  630:  /// Strip off pointer casts, all-zero GEPs and address space casts.
        -:  631:  ///
        -:  632:  /// Returns the original uncasted value.  If this is called on a non-pointer
        -:  633:  /// value, it returns 'this'.
        -:  634:  const Value *stripPointerCasts() const;
        -:  635:  Value *stripPointerCasts() {
        -:  636:    return const_cast<Value *>(
        -:  637:        static_cast<const Value *>(this)->stripPointerCasts());
        -:  638:  }
        -:  639:
        -:  640:  /// Strip off pointer casts, all-zero GEPs, address space casts, and aliases.
        -:  641:  ///
        -:  642:  /// Returns the original uncasted value.  If this is called on a non-pointer
        -:  643:  /// value, it returns 'this'.
        -:  644:  const Value *stripPointerCastsAndAliases() const;
        -:  645:  Value *stripPointerCastsAndAliases() {
        -:  646:    return const_cast<Value *>(
        -:  647:        static_cast<const Value *>(this)->stripPointerCastsAndAliases());
        -:  648:  }
        -:  649:
        -:  650:  /// Strip off pointer casts, all-zero GEPs and address space casts
        -:  651:  /// but ensures the representation of the result stays the same.
        -:  652:  ///
        -:  653:  /// Returns the original uncasted value with the same representation. If this
        -:  654:  /// is called on a non-pointer value, it returns 'this'.
        -:  655:  const Value *stripPointerCastsSameRepresentation() const;
        -:  656:  Value *stripPointerCastsSameRepresentation() {
        -:  657:    return const_cast<Value *>(static_cast<const Value *>(this)
        -:  658:                                   ->stripPointerCastsSameRepresentation());
        -:  659:  }
        -:  660:
        -:  661:  /// Strip off pointer casts, all-zero GEPs, single-argument phi nodes and
        -:  662:  /// invariant group info.
        -:  663:  ///
        -:  664:  /// Returns the original uncasted value.  If this is called on a non-pointer
        -:  665:  /// value, it returns 'this'. This function should be used only in
        -:  666:  /// Alias analysis.
        -:  667:  const Value *stripPointerCastsForAliasAnalysis() const;
        -:  668:  Value *stripPointerCastsForAliasAnalysis() {
        -:  669:    return const_cast<Value *>(static_cast<const Value *>(this)
        -:  670:                                   ->stripPointerCastsForAliasAnalysis());
        -:  671:  }
        -:  672:
        -:  673:  /// Strip off pointer casts and all-constant inbounds GEPs.
        -:  674:  ///
        -:  675:  /// Returns the original pointer value.  If this is called on a non-pointer
        -:  676:  /// value, it returns 'this'.
        -:  677:  const Value *stripInBoundsConstantOffsets() const;
        -:  678:  Value *stripInBoundsConstantOffsets() {
        -:  679:    return const_cast<Value *>(
        -:  680:              static_cast<const Value *>(this)->stripInBoundsConstantOffsets());
        -:  681:  }
        -:  682:
        -:  683:  /// Accumulate the constant offset this value has compared to a base pointer.
        -:  684:  /// Only 'getelementptr' instructions (GEPs) are accumulated but other
        -:  685:  /// instructions, e.g., casts, are stripped away as well.
        -:  686:  /// The accumulated constant offset is added to \p Offset and the base
        -:  687:  /// pointer is returned.
        -:  688:  ///
        -:  689:  /// The APInt \p Offset has to have a bit-width equal to the IntPtr type for
        -:  690:  /// the address space of 'this' pointer value, e.g., use
        -:  691:  /// DataLayout::getIndexTypeSizeInBits(Ty).
        -:  692:  ///
        -:  693:  /// If \p AllowNonInbounds is true, offsets in GEPs are stripped and
        -:  694:  /// accumulated even if the GEP is not "inbounds".
        -:  695:  ///
        -:  696:  /// If \p AllowInvariantGroup is true then this method also looks through
        -:  697:  /// strip.invariant.group and launder.invariant.group intrinsics.
        -:  698:  ///
        -:  699:  /// If \p ExternalAnalysis is provided it will be used to calculate a offset
        -:  700:  /// when a operand of GEP is not constant.
        -:  701:  /// For example, for a value \p ExternalAnalysis might try to calculate a
        -:  702:  /// lower bound. If \p ExternalAnalysis is successful, it should return true.
        -:  703:  ///
        -:  704:  /// If this is called on a non-pointer value, it returns 'this' and the
        -:  705:  /// \p Offset is not modified.
        -:  706:  ///
        -:  707:  /// Note that this function will never return a nullptr. It will also never
        -:  708:  /// manipulate the \p Offset in a way that would not match the difference
        -:  709:  /// between the underlying value and the returned one. Thus, if no constant
        -:  710:  /// offset was found, the returned value is the underlying one and \p Offset
        -:  711:  /// is unchanged.
        -:  712:  const Value *stripAndAccumulateConstantOffsets(
        -:  713:      const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,
        -:  714:      bool AllowInvariantGroup = false,
        -:  715:      function_ref<bool(Value &Value, APInt &Offset)> ExternalAnalysis =
        -:  716:          nullptr) const;
        -:  717:  Value *stripAndAccumulateConstantOffsets(const DataLayout &DL, APInt &Offset,
        -:  718:                                           bool AllowNonInbounds,
        -:  719:                                           bool AllowInvariantGroup = false) {
        -:  720:    return const_cast<Value *>(
        -:  721:        static_cast<const Value *>(this)->stripAndAccumulateConstantOffsets(
        -:  722:            DL, Offset, AllowNonInbounds, AllowInvariantGroup));
        -:  723:  }
        -:  724:
        -:  725:  /// This is a wrapper around stripAndAccumulateConstantOffsets with the
        -:  726:  /// in-bounds requirement set to false.
        -:  727:  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,
        -:  728:                                                         APInt &Offset) const {
        -:  729:    return stripAndAccumulateConstantOffsets(DL, Offset,
        -:  730:                                             /* AllowNonInbounds */ false);
        -:  731:  }
        -:  732:  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,
        -:  733:                                                   APInt &Offset) {
        -:  734:    return stripAndAccumulateConstantOffsets(DL, Offset,
        -:  735:                                             /* AllowNonInbounds */ false);
        -:  736:  }
        -:  737:
        -:  738:  /// Strip off pointer casts and inbounds GEPs.
        -:  739:  ///
        -:  740:  /// Returns the original pointer value.  If this is called on a non-pointer
        -:  741:  /// value, it returns 'this'.
        -:  742:  const Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =
        -:  743:                                        [](const Value *) {}) const;
        -:  744:  inline Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =
        -:  745:                                  [](const Value *) {}) {
        -:  746:    return const_cast<Value *>(
        -:  747:        static_cast<const Value *>(this)->stripInBoundsOffsets(Func));
        -:  748:  }
        -:  749:
        -:  750:  /// Return true if the memory object referred to by V can by freed in the
        -:  751:  /// scope for which the SSA value defining the allocation is statically
        -:  752:  /// defined.  E.g.  deallocation after the static scope of a value does not
        -:  753:  /// count, but a deallocation before that does.
        -:  754:  bool canBeFreed() const;
        -:  755:
        -:  756:  /// Returns the number of bytes known to be dereferenceable for the
        -:  757:  /// pointer value.
        -:  758:  ///
        -:  759:  /// If CanBeNull is set by this function the pointer can either be null or be
        -:  760:  /// dereferenceable up to the returned number of bytes.
        -:  761:  ///
        -:  762:  /// IF CanBeFreed is true, the pointer is known to be dereferenceable at
        -:  763:  /// point of definition only.  Caller must prove that allocation is not
        -:  764:  /// deallocated between point of definition and use.
        -:  765:  uint64_t getPointerDereferenceableBytes(const DataLayout &DL,
        -:  766:                                          bool &CanBeNull,
        -:  767:                                          bool &CanBeFreed) const;
        -:  768:
        -:  769:  /// Returns an alignment of the pointer value.
        -:  770:  ///
        -:  771:  /// Returns an alignment which is either specified explicitly, e.g. via
        -:  772:  /// align attribute of a function argument, or guaranteed by DataLayout.
        -:  773:  Align getPointerAlignment(const DataLayout &DL) const;
        -:  774:
        -:  775:  /// Translate PHI node to its predecessor from the given basic block.
        -:  776:  ///
        -:  777:  /// If this value is a PHI node with CurBB as its parent, return the value in
        -:  778:  /// the PHI node corresponding to PredBB.  If not, return ourself.  This is
        -:  779:  /// useful if you want to know the value something has in a predecessor
        -:  780:  /// block.
        -:  781:  const Value *DoPHITranslation(const BasicBlock *CurBB,
        -:  782:                                const BasicBlock *PredBB) const;
        -:  783:  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB) {
        -:  784:    return const_cast<Value *>(
        -:  785:             static_cast<const Value *>(this)->DoPHITranslation(CurBB, PredBB));
        -:  786:  }
        -:  787:
        -:  788:  /// The maximum alignment for instructions.
        -:  789:  ///
        -:  790:  /// This is the greatest alignment value supported by load, store, and alloca
        -:  791:  /// instructions, and global values.
        -:  792:  static constexpr unsigned MaxAlignmentExponent = 32;
        -:  793:  static constexpr uint64_t MaximumAlignment = 1ULL << MaxAlignmentExponent;
        -:  794:
        -:  795:  /// Mutate the type of this Value to be of the specified type.
        -:  796:  ///
        -:  797:  /// Note that this is an extremely dangerous operation which can create
        -:  798:  /// completely invalid IR very easily.  It is strongly recommended that you
        -:  799:  /// recreate IR objects with the right types instead of mutating them in
        -:  800:  /// place.
        -:  801:  void mutateType(Type *Ty) {
        -:  802:    VTy = Ty;
        -:  803:  }
        -:  804:
        -:  805:  /// Sort the use-list.
        -:  806:  ///
        -:  807:  /// Sorts the Value's use-list by Cmp using a stable mergesort.  Cmp is
        -:  808:  /// expected to compare two \a Use references.
        -:  809:  template <class Compare> void sortUseList(Compare Cmp);
        -:  810:
        -:  811:  /// Reverse the use-list.
        -:  812:  void reverseUseList();
        -:  813:
        -:  814:private:
        -:  815:  /// Merge two lists together.
        -:  816:  ///
        -:  817:  /// Merges \c L and \c R using \c Cmp.  To enable stable sorts, always pushes
        -:  818:  /// "equal" items from L before items from R.
        -:  819:  ///
        -:  820:  /// \return the first element in the list.
        -:  821:  ///
        -:  822:  /// \note Completely ignores \a Use::Prev (doesn't read, doesn't update).
        -:  823:  template <class Compare>
        -:  824:  static Use *mergeUseLists(Use *L, Use *R, Compare Cmp) {
        -:  825:    Use *Merged;
        -:  826:    Use **Next = &Merged;
        -:  827:
        -:  828:    while (true) {
        -:  829:      if (!L) {
        -:  830:        *Next = R;
        -:  831:        break;
        -:  832:      }
        -:  833:      if (!R) {
        -:  834:        *Next = L;
        -:  835:        break;
        -:  836:      }
        -:  837:      if (Cmp(*R, *L)) {
        -:  838:        *Next = R;
        -:  839:        Next = &R->Next;
        -:  840:        R = R->Next;
        -:  841:      } else {
        -:  842:        *Next = L;
        -:  843:        Next = &L->Next;
        -:  844:        L = L->Next;
        -:  845:      }
        -:  846:    }
        -:  847:
        -:  848:    return Merged;
        -:  849:  }
        -:  850:
        -:  851:protected:
    #####:  852:  unsigned short getSubclassDataFromValue() const { return SubclassData; }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  853:  void setValueSubclassData(unsigned short D) { SubclassData = D; }
call    0 never executed
        -:  854:};
        -:  855:
        -:  856:struct ValueDeleter { void operator()(Value *V) { V->deleteValue(); } };
        -:  857:
        -:  858:/// Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.
        -:  859:/// Those don't work because Value and Instruction's destructors are protected,
        -:  860:/// aren't virtual, and won't destroy the complete object.
        -:  861:using unique_value = std::unique_ptr<Value, ValueDeleter>;
        -:  862:
        -:  863:inline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {
        -:  864:  V.print(OS);
        -:  865:  return OS;
        -:  866:}
        -:  867:
    #####:  868:void Use::set(Value *V) {
    #####:  869:  if (Val) removeFromList();
branch  0 never executed
branch  1 never executed
    #####:  870:  Val = V;
    #####:  871:  if (V) V->addUse(*this);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  872:}
        -:  873:
    #####:  874:Value *Use::operator=(Value *RHS) {
    #####:  875:  set(RHS);
branch  0 never executed
branch  1 never executed
    #####:  876:  return RHS;
        -:  877:}
        -:  878:
        -:  879:const Use &Use::operator=(const Use &RHS) {
        -:  880:  set(RHS.Val);
        -:  881:  return *this;
        -:  882:}
        -:  883:
        -:  884:template <class Compare> void Value::sortUseList(Compare Cmp) {
        -:  885:  if (!UseList || !UseList->Next)
        -:  886:    // No need to sort 0 or 1 uses.
        -:  887:    return;
        -:  888:
        -:  889:  // Note: this function completely ignores Prev pointers until the end when
        -:  890:  // they're fixed en masse.
        -:  891:
        -:  892:  // Create a binomial vector of sorted lists, visiting uses one at a time and
        -:  893:  // merging lists as necessary.
        -:  894:  const unsigned MaxSlots = 32;
        -:  895:  Use *Slots[MaxSlots];
        -:  896:
        -:  897:  // Collect the first use, turning it into a single-item list.
        -:  898:  Use *Next = UseList->Next;
        -:  899:  UseList->Next = nullptr;
        -:  900:  unsigned NumSlots = 1;
        -:  901:  Slots[0] = UseList;
        -:  902:
        -:  903:  // Collect all but the last use.
        -:  904:  while (Next->Next) {
        -:  905:    Use *Current = Next;
        -:  906:    Next = Current->Next;
        -:  907:
        -:  908:    // Turn Current into a single-item list.
        -:  909:    Current->Next = nullptr;
        -:  910:
        -:  911:    // Save Current in the first available slot, merging on collisions.
        -:  912:    unsigned I;
        -:  913:    for (I = 0; I < NumSlots; ++I) {
        -:  914:      if (!Slots[I])
        -:  915:        break;
        -:  916:
        -:  917:      // Merge two lists, doubling the size of Current and emptying slot I.
        -:  918:      //
        -:  919:      // Since the uses in Slots[I] originally preceded those in Current, send
        -:  920:      // Slots[I] in as the left parameter to maintain a stable sort.
        -:  921:      Current = mergeUseLists(Slots[I], Current, Cmp);
        -:  922:      Slots[I] = nullptr;
        -:  923:    }
        -:  924:    // Check if this is a new slot.
        -:  925:    if (I == NumSlots) {
        -:  926:      ++NumSlots;
        -:  927:      assert(NumSlots <= MaxSlots && "Use list bigger than 2^32");
        -:  928:    }
        -:  929:
        -:  930:    // Found an open slot.
        -:  931:    Slots[I] = Current;
        -:  932:  }
        -:  933:
        -:  934:  // Merge all the lists together.
        -:  935:  assert(Next && "Expected one more Use");
        -:  936:  assert(!Next->Next && "Expected only one Use");
        -:  937:  UseList = Next;
        -:  938:  for (unsigned I = 0; I < NumSlots; ++I)
        -:  939:    if (Slots[I])
        -:  940:      // Since the uses in Slots[I] originally preceded those in UseList, send
        -:  941:      // Slots[I] in as the left parameter to maintain a stable sort.
        -:  942:      UseList = mergeUseLists(Slots[I], UseList, Cmp);
        -:  943:
        -:  944:  // Fix the Prev pointers.
        -:  945:  for (Use *I = UseList, **Prev = &UseList; I; I = I->Next) {
        -:  946:    I->Prev = Prev;
        -:  947:    Prev = &I->Next;
        -:  948:  }
        -:  949:}
        -:  950:
        -:  951:// isa - Provide some specializations of isa so that we don't have to include
        -:  952:// the subtype header files to test to see if the value is a subclass...
        -:  953://
        -:  954:template <> struct isa_impl<Constant, Value> {
    #####:  955:  static inline bool doit(const Value &Val) {
    #####:  956:    static_assert(Value::ConstantFirstVal == 0, "Val.getValueID() >= Value::ConstantFirstVal");
    #####:  957:    return Val.getValueID() <= Value::ConstantLastVal;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
branch 59 never executed
        -:  958:  }
        -:  959:};
        -:  960:
        -:  961:template <> struct isa_impl<ConstantData, Value> {
        -:  962:  static inline bool doit(const Value &Val) {
        -:  963:    return Val.getValueID() >= Value::ConstantDataFirstVal &&
        -:  964:           Val.getValueID() <= Value::ConstantDataLastVal;
        -:  965:  }
        -:  966:};
        -:  967:
        -:  968:template <> struct isa_impl<ConstantAggregate, Value> {
        -:  969:  static inline bool doit(const Value &Val) {
        -:  970:    return Val.getValueID() >= Value::ConstantAggregateFirstVal &&
        -:  971:           Val.getValueID() <= Value::ConstantAggregateLastVal;
        -:  972:  }
        -:  973:};
        -:  974:
        -:  975:template <> struct isa_impl<Argument, Value> {
        -:  976:  static inline bool doit (const Value &Val) {
        -:  977:    return Val.getValueID() == Value::ArgumentVal;
        -:  978:  }
        -:  979:};
        -:  980:
        -:  981:template <> struct isa_impl<InlineAsm, Value> {
        -:  982:  static inline bool doit(const Value &Val) {
        -:  983:    return Val.getValueID() == Value::InlineAsmVal;
        -:  984:  }
        -:  985:};
        -:  986:
        -:  987:template <> struct isa_impl<Instruction, Value> {
    #####:  988:  static inline bool doit(const Value &Val) {
    #####:  989:    return Val.getValueID() >= Value::InstructionVal;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  990:  }
        -:  991:};
        -:  992:
        -:  993:template <> struct isa_impl<BasicBlock, Value> {
        -:  994:  static inline bool doit(const Value &Val) {
        -:  995:    return Val.getValueID() == Value::BasicBlockVal;
        -:  996:  }
        -:  997:};
        -:  998:
        -:  999:template <> struct isa_impl<Function, Value> {
        -: 1000:  static inline bool doit(const Value &Val) {
        -: 1001:    return Val.getValueID() == Value::FunctionVal;
        -: 1002:  }
        -: 1003:};
        -: 1004:
        -: 1005:template <> struct isa_impl<GlobalVariable, Value> {
        -: 1006:  static inline bool doit(const Value &Val) {
        -: 1007:    return Val.getValueID() == Value::GlobalVariableVal;
        -: 1008:  }
        -: 1009:};
        -: 1010:
        -: 1011:template <> struct isa_impl<GlobalAlias, Value> {
        -: 1012:  static inline bool doit(const Value &Val) {
        -: 1013:    return Val.getValueID() == Value::GlobalAliasVal;
        -: 1014:  }
        -: 1015:};
        -: 1016:
        -: 1017:template <> struct isa_impl<GlobalIFunc, Value> {
        -: 1018:  static inline bool doit(const Value &Val) {
        -: 1019:    return Val.getValueID() == Value::GlobalIFuncVal;
        -: 1020:  }
        -: 1021:};
        -: 1022:
        -: 1023:template <> struct isa_impl<GlobalValue, Value> {
        -: 1024:  static inline bool doit(const Value &Val) {
        -: 1025:    return isa<GlobalObject>(Val) || isa<GlobalAlias>(Val);
        -: 1026:  }
        -: 1027:};
        -: 1028:
        -: 1029:template <> struct isa_impl<GlobalObject, Value> {
        -: 1030:  static inline bool doit(const Value &Val) {
        -: 1031:    return isa<GlobalVariable>(Val) || isa<Function>(Val) ||
        -: 1032:           isa<GlobalIFunc>(Val);
        -: 1033:  }
        -: 1034:};
        -: 1035:
        -: 1036:// Create wrappers for C Binding types (see CBindingWrapping.h).
        -: 1037:DEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef)
        -: 1038:
        -: 1039:// Specialized opaque value conversions.
        -: 1040:inline Value **unwrap(LLVMValueRef *Vals) {
        -: 1041:  return reinterpret_cast<Value**>(Vals);
        -: 1042:}
        -: 1043:
        -: 1044:template<typename T>
        -: 1045:inline T **unwrap(LLVMValueRef *Vals, unsigned Length) {
        -: 1046:#ifndef NDEBUG
        -: 1047:  for (LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I)
        -: 1048:    unwrap<T>(*I); // For side effect of calling assert on invalid usage.
        -: 1049:#endif
        -: 1050:  (void)Length;
        -: 1051:  return reinterpret_cast<T**>(Vals);
        -: 1052:}
        -: 1053:
        -: 1054:inline LLVMValueRef *wrap(const Value **Vals) {
        -: 1055:  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));
        -: 1056:}
        -: 1057:
        -: 1058:} // end namespace llvm
        -: 1059:
        -: 1060:#endif // LLVM_IR_VALUE_H
