        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/IR/Function.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===- llvm/Function.h - Class to represent a single function ---*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains the declaration of the Function class, which represents a
        -:   10:// single function/procedure in LLVM.
        -:   11://
        -:   12:// A function basically consists of a list of basic blocks, a list of arguments,
        -:   13:// and a symbol table.
        -:   14://
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#ifndef LLVM_IR_FUNCTION_H
        -:   18:#define LLVM_IR_FUNCTION_H
        -:   19:
        -:   20:#include "llvm/ADT/DenseSet.h"
        -:   21:#include "llvm/ADT/StringRef.h"
        -:   22:#include "llvm/ADT/Twine.h"
        -:   23:#include "llvm/ADT/ilist_node.h"
        -:   24:#include "llvm/ADT/iterator_range.h"
        -:   25:#include "llvm/IR/Argument.h"
        -:   26:#include "llvm/IR/Attributes.h"
        -:   27:#include "llvm/IR/BasicBlock.h"
        -:   28:#include "llvm/IR/CallingConv.h"
        -:   29:#include "llvm/IR/DerivedTypes.h"
        -:   30:#include "llvm/IR/GlobalObject.h"
        -:   31:#include "llvm/IR/GlobalValue.h"
        -:   32:#include "llvm/IR/OperandTraits.h"
        -:   33:#include "llvm/IR/SymbolTableListTraits.h"
        -:   34:#include "llvm/IR/Value.h"
        -:   35:#include <cassert>
        -:   36:#include <cstddef>
        -:   37:#include <cstdint>
        -:   38:#include <memory>
        -:   39:#include <string>
        -:   40:
        -:   41:namespace llvm {
        -:   42:
        -:   43:namespace Intrinsic {
        -:   44:typedef unsigned ID;
        -:   45:}
        -:   46:
        -:   47:class AssemblyAnnotationWriter;
        -:   48:class Constant;
        -:   49:struct DenormalMode;
        -:   50:class DISubprogram;
        -:   51:class LLVMContext;
        -:   52:class Module;
        -:   53:template <typename T> class Optional;
        -:   54:class raw_ostream;
        -:   55:class Type;
        -:   56:class User;
        -:   57:class BranchProbabilityInfo;
        -:   58:class BlockFrequencyInfo;
        -:   59:
        -:   60:class LLVM_EXTERNAL_VISIBILITY Function : public GlobalObject,
        -:   61:                                          public ilist_node<Function> {
        -:   62:public:
        -:   63:  using BasicBlockListType = SymbolTableList<BasicBlock>;
        -:   64:
        -:   65:  // BasicBlock iterators...
        -:   66:  using iterator = BasicBlockListType::iterator;
        -:   67:  using const_iterator = BasicBlockListType::const_iterator;
        -:   68:
        -:   69:  using arg_iterator = Argument *;
        -:   70:  using const_arg_iterator = const Argument *;
        -:   71:
        -:   72:private:
        -:   73:  // Important things that make up a function!
        -:   74:  BasicBlockListType BasicBlocks;         ///< The basic blocks
        -:   75:  mutable Argument *Arguments = nullptr;  ///< The formal arguments
        -:   76:  size_t NumArgs;
        -:   77:  std::unique_ptr<ValueSymbolTable>
        -:   78:      SymTab;                             ///< Symbol table of args/instructions
        -:   79:  AttributeList AttributeSets;            ///< Parameter attributes
        -:   80:
        -:   81:  /*
        -:   82:   * Value::SubclassData
        -:   83:   *
        -:   84:   * bit 0      : HasLazyArguments
        -:   85:   * bit 1      : HasPrefixData
        -:   86:   * bit 2      : HasPrologueData
        -:   87:   * bit 3      : HasPersonalityFn
        -:   88:   * bits 4-13  : CallingConvention
        -:   89:   * bits 14    : HasGC
        -:   90:   * bits 15 : [reserved]
        -:   91:   */
        -:   92:
        -:   93:  /// Bits from GlobalObject::GlobalObjectSubclassData.
        -:   94:  enum {
        -:   95:    /// Whether this function is materializable.
        -:   96:    IsMaterializableBit = 0,
        -:   97:  };
        -:   98:
        -:   99:  friend class SymbolTableListTraits<Function>;
        -:  100:
        -:  101:  /// hasLazyArguments/CheckLazyArguments - The argument list of a function is
        -:  102:  /// built on demand, so that the list isn't allocated until the first client
        -:  103:  /// needs it.  The hasLazyArguments predicate returns true if the arg list
        -:  104:  /// hasn't been set up yet.
        -:  105:public:
        -:  106:  bool hasLazyArguments() const {
        -:  107:    return getSubclassDataFromValue() & (1<<0);
        -:  108:  }
        -:  109:
        -:  110:private:
        -:  111:  void CheckLazyArguments() const {
        -:  112:    if (hasLazyArguments())
        -:  113:      BuildLazyArguments();
        -:  114:  }
        -:  115:
        -:  116:  void BuildLazyArguments() const;
        -:  117:
        -:  118:  void clearArguments();
        -:  119:
        -:  120:  /// Function ctor - If the (optional) Module argument is specified, the
        -:  121:  /// function is automatically inserted into the end of the function list for
        -:  122:  /// the module.
        -:  123:  ///
        -:  124:  Function(FunctionType *Ty, LinkageTypes Linkage, unsigned AddrSpace,
        -:  125:           const Twine &N = "", Module *M = nullptr);
        -:  126:
        -:  127:public:
        -:  128:  Function(const Function&) = delete;
        -:  129:  void operator=(const Function&) = delete;
        -:  130:  ~Function();
        -:  131:
        -:  132:  // This is here to help easily convert from FunctionT * (Function * or
        -:  133:  // MachineFunction *) in BlockFrequencyInfoImpl to Function * by calling
        -:  134:  // FunctionT->getFunction().
        -:  135:  const Function &getFunction() const { return *this; }
        -:  136:
        -:  137:  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
        -:  138:                          unsigned AddrSpace, const Twine &N = "",
        -:  139:                          Module *M = nullptr) {
        -:  140:    return new Function(Ty, Linkage, AddrSpace, N, M);
        -:  141:  }
        -:  142:
        -:  143:  // TODO: remove this once all users have been updated to pass an AddrSpace
        -:  144:  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
        -:  145:                          const Twine &N = "", Module *M = nullptr) {
        -:  146:    return new Function(Ty, Linkage, static_cast<unsigned>(-1), N, M);
        -:  147:  }
        -:  148:
        -:  149:  /// Creates a new function and attaches it to a module.
        -:  150:  ///
        -:  151:  /// Places the function in the program address space as specified
        -:  152:  /// by the module's data layout.
        -:  153:  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
        -:  154:                          const Twine &N, Module &M);
        -:  155:
        -:  156:  /// Creates a function with some attributes recorded in llvm.module.flags
        -:  157:  /// applied.
        -:  158:  ///
        -:  159:  /// Use this when synthesizing new functions that need attributes that would
        -:  160:  /// have been set by command line options.
        -:  161:  static Function *createWithDefaultAttr(FunctionType *Ty, LinkageTypes Linkage,
        -:  162:                                         unsigned AddrSpace,
        -:  163:                                         const Twine &N = "",
        -:  164:                                         Module *M = nullptr);
        -:  165:
        -:  166:  // Provide fast operand accessors.
        -:  167:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:  168:
        -:  169:  /// Returns the number of non-debug IR instructions in this function.
        -:  170:  /// This is equivalent to the sum of the sizes of each basic block contained
        -:  171:  /// within this function.
        -:  172:  unsigned getInstructionCount() const;
        -:  173:
        -:  174:  /// Returns the FunctionType for me.
    #####:  175:  FunctionType *getFunctionType() const {
    #####:  176:    return cast<FunctionType>(getValueType());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
call   129 never executed
call   130 never executed
call   131 never executed
call   132 never executed
call   133 never executed
call   134 never executed
call   135 never executed
call   136 never executed
call   137 never executed
call   138 never executed
        -:  177:  }
        -:  178:
        -:  179:  /// Returns the type of the ret val.
        -:  180:  Type *getReturnType() const { return getFunctionType()->getReturnType(); }
        -:  181:
        -:  182:  /// getContext - Return a reference to the LLVMContext associated with this
        -:  183:  /// function.
        -:  184:  LLVMContext &getContext() const;
        -:  185:
        -:  186:  /// isVarArg - Return true if this function takes a variable number of
        -:  187:  /// arguments.
        -:  188:  bool isVarArg() const { return getFunctionType()->isVarArg(); }
        -:  189:
        -:  190:  bool isMaterializable() const {
        -:  191:    return getGlobalObjectSubClassData() & (1 << IsMaterializableBit);
        -:  192:  }
        -:  193:  void setIsMaterializable(bool V) {
        -:  194:    unsigned Mask = 1 << IsMaterializableBit;
        -:  195:    setGlobalObjectSubClassData((~Mask & getGlobalObjectSubClassData()) |
        -:  196:                                (V ? Mask : 0u));
        -:  197:  }
        -:  198:
        -:  199:  /// getIntrinsicID - This method returns the ID number of the specified
        -:  200:  /// function, or Intrinsic::not_intrinsic if the function is not an
        -:  201:  /// intrinsic, or if the pointer is null.  This value is always defined to be
        -:  202:  /// zero to allow easy checking for whether a function is intrinsic or not.
        -:  203:  /// The particular intrinsic functions which correspond to this value are
        -:  204:  /// defined in llvm/Intrinsics.h.
        -:  205:  Intrinsic::ID getIntrinsicID() const LLVM_READONLY { return IntID; }
        -:  206:
        -:  207:  /// isIntrinsic - Returns true if the function's name starts with "llvm.".
        -:  208:  /// It's possible for this function to return true while getIntrinsicID()
        -:  209:  /// returns Intrinsic::not_intrinsic!
        -:  210:  bool isIntrinsic() const { return HasLLVMReservedName; }
        -:  211:
        -:  212:  /// isTargetIntrinsic - Returns true if IID is an intrinsic specific to a
        -:  213:  /// certain target. If it is a generic intrinsic false is returned.
        -:  214:  static bool isTargetIntrinsic(Intrinsic::ID IID);
        -:  215:
        -:  216:  /// isTargetIntrinsic - Returns true if this function is an intrinsic and the
        -:  217:  /// intrinsic is specific to a certain target. If this is not an intrinsic
        -:  218:  /// or a generic intrinsic, false is returned.
        -:  219:  bool isTargetIntrinsic() const;
        -:  220:
        -:  221:  /// Returns true if the function is one of the "Constrained Floating-Point
        -:  222:  /// Intrinsics". Returns false if not, and returns false when
        -:  223:  /// getIntrinsicID() returns Intrinsic::not_intrinsic.
        -:  224:  bool isConstrainedFPIntrinsic() const;
        -:  225:
        -:  226:  static Intrinsic::ID lookupIntrinsicID(StringRef Name);
        -:  227:
        -:  228:  /// Recalculate the ID for this function if it is an Intrinsic defined
        -:  229:  /// in llvm/Intrinsics.h.  Sets the intrinsic ID to Intrinsic::not_intrinsic
        -:  230:  /// if the name of this function does not match an intrinsic in that header.
        -:  231:  /// Note, this method does not need to be called directly, as it is called
        -:  232:  /// from Value::setName() whenever the name of this function changes.
        -:  233:  void recalculateIntrinsicID();
        -:  234:
        -:  235:  /// getCallingConv()/setCallingConv(CC) - These method get and set the
        -:  236:  /// calling convention of this function.  The enum values for the known
        -:  237:  /// calling conventions are defined in CallingConv.h.
        -:  238:  CallingConv::ID getCallingConv() const {
        -:  239:    return static_cast<CallingConv::ID>((getSubclassDataFromValue() >> 4) &
        -:  240:                                        CallingConv::MaxID);
        -:  241:  }
        -:  242:  void setCallingConv(CallingConv::ID CC) {
        -:  243:    auto ID = static_cast<unsigned>(CC);
        -:  244:    assert(!(ID & ~CallingConv::MaxID) && "Unsupported calling convention");
        -:  245:    setValueSubclassData((getSubclassDataFromValue() & 0xc00f) | (ID << 4));
        -:  246:  }
        -:  247:
        -:  248:  enum ProfileCountType { PCT_Real, PCT_Synthetic };
        -:  249:
        -:  250:  /// Class to represent profile counts.
        -:  251:  ///
        -:  252:  /// This class represents both real and synthetic profile counts.
        -:  253:  class ProfileCount {
        -:  254:  private:
        -:  255:    uint64_t Count = 0;
        -:  256:    ProfileCountType PCT = PCT_Real;
        -:  257:
        -:  258:  public:
        -:  259:    ProfileCount(uint64_t Count, ProfileCountType PCT)
        -:  260:        : Count(Count), PCT(PCT) {}
        -:  261:    uint64_t getCount() const { return Count; }
        -:  262:    ProfileCountType getType() const { return PCT; }
        -:  263:    bool isSynthetic() const { return PCT == PCT_Synthetic; }
        -:  264:  };
        -:  265:
        -:  266:  /// Set the entry count for this function.
        -:  267:  ///
        -:  268:  /// Entry count is the number of times this function was executed based on
        -:  269:  /// pgo data. \p Imports points to a set of GUIDs that needs to
        -:  270:  /// be imported by the function for sample PGO, to enable the same inlines as
        -:  271:  /// the profiled optimized binary.
        -:  272:  void setEntryCount(ProfileCount Count,
        -:  273:                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);
        -:  274:
        -:  275:  /// A convenience wrapper for setting entry count
        -:  276:  void setEntryCount(uint64_t Count, ProfileCountType Type = PCT_Real,
        -:  277:                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);
        -:  278:
        -:  279:  /// Get the entry count for this function.
        -:  280:  ///
        -:  281:  /// Entry count is the number of times the function was executed.
        -:  282:  /// When AllowSynthetic is false, only pgo_data will be returned.
        -:  283:  Optional<ProfileCount> getEntryCount(bool AllowSynthetic = false) const;
        -:  284:
        -:  285:  /// Return true if the function is annotated with profile data.
        -:  286:  ///
        -:  287:  /// Presence of entry counts from a profile run implies the function has
        -:  288:  /// profile annotations. If IncludeSynthetic is false, only return true
        -:  289:  /// when the profile data is real.
        -:  290:  bool hasProfileData(bool IncludeSynthetic = false) const {
        -:  291:    return getEntryCount(IncludeSynthetic).has_value();
        -:  292:  }
        -:  293:
        -:  294:  /// Returns the set of GUIDs that needs to be imported to the function for
        -:  295:  /// sample PGO, to enable the same inlines as the profiled optimized binary.
        -:  296:  DenseSet<GlobalValue::GUID> getImportGUIDs() const;
        -:  297:
        -:  298:  /// Set the section prefix for this function.
        -:  299:  void setSectionPrefix(StringRef Prefix);
        -:  300:
        -:  301:  /// Get the section prefix for this function.
        -:  302:  Optional<StringRef> getSectionPrefix() const;
        -:  303:
        -:  304:  /// hasGC/getGC/setGC/clearGC - The name of the garbage collection algorithm
        -:  305:  ///                             to use during code generation.
        -:  306:  bool hasGC() const {
        -:  307:    return getSubclassDataFromValue() & (1<<14);
        -:  308:  }
        -:  309:  const std::string &getGC() const;
        -:  310:  void setGC(std::string Str);
        -:  311:  void clearGC();
        -:  312:
        -:  313:  /// Return the attribute list for this Function.
        -:  314:  AttributeList getAttributes() const { return AttributeSets; }
        -:  315:
        -:  316:  /// Set the attribute list for this Function.
        -:  317:  void setAttributes(AttributeList Attrs) { AttributeSets = Attrs; }
        -:  318:
        -:  319:  // TODO: remove non-AtIndex versions of these methods.
        -:  320:  /// adds the attribute to the list of attributes.
        -:  321:  void addAttributeAtIndex(unsigned i, Attribute Attr);
        -:  322:
        -:  323:  /// Add function attributes to this function.
        -:  324:  void addFnAttr(Attribute::AttrKind Kind);
        -:  325:
        -:  326:  /// Add function attributes to this function.
        -:  327:  void addFnAttr(StringRef Kind, StringRef Val = StringRef());
        -:  328:
        -:  329:  /// Add function attributes to this function.
        -:  330:  void addFnAttr(Attribute Attr);
        -:  331:
        -:  332:  /// Add function attributes to this function.
        -:  333:  void addFnAttrs(const AttrBuilder &Attrs);
        -:  334:
        -:  335:  /// Add return value attributes to this function.
        -:  336:  void addRetAttr(Attribute::AttrKind Kind);
        -:  337:
        -:  338:  /// Add return value attributes to this function.
        -:  339:  void addRetAttr(Attribute Attr);
        -:  340:
        -:  341:  /// Add return value attributes to this function.
        -:  342:  void addRetAttrs(const AttrBuilder &Attrs);
        -:  343:
        -:  344:  /// adds the attribute to the list of attributes for the given arg.
        -:  345:  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);
        -:  346:
        -:  347:  /// adds the attribute to the list of attributes for the given arg.
        -:  348:  void addParamAttr(unsigned ArgNo, Attribute Attr);
        -:  349:
        -:  350:  /// adds the attributes to the list of attributes for the given arg.
        -:  351:  void addParamAttrs(unsigned ArgNo, const AttrBuilder &Attrs);
        -:  352:
        -:  353:  /// removes the attribute from the list of attributes.
        -:  354:  void removeAttributeAtIndex(unsigned i, Attribute::AttrKind Kind);
        -:  355:
        -:  356:  /// removes the attribute from the list of attributes.
        -:  357:  void removeAttributeAtIndex(unsigned i, StringRef Kind);
        -:  358:
        -:  359:  /// Remove function attributes from this function.
        -:  360:  void removeFnAttr(Attribute::AttrKind Kind);
        -:  361:
        -:  362:  /// Remove function attribute from this function.
        -:  363:  void removeFnAttr(StringRef Kind);
        -:  364:
        -:  365:  void removeFnAttrs(const AttributeMask &Attrs);
        -:  366:
        -:  367:  /// removes the attribute from the return value list of attributes.
        -:  368:  void removeRetAttr(Attribute::AttrKind Kind);
        -:  369:
        -:  370:  /// removes the attribute from the return value list of attributes.
        -:  371:  void removeRetAttr(StringRef Kind);
        -:  372:
        -:  373:  /// removes the attributes from the return value list of attributes.
        -:  374:  void removeRetAttrs(const AttributeMask &Attrs);
        -:  375:
        -:  376:  /// removes the attribute from the list of attributes.
        -:  377:  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);
        -:  378:
        -:  379:  /// removes the attribute from the list of attributes.
        -:  380:  void removeParamAttr(unsigned ArgNo, StringRef Kind);
        -:  381:
        -:  382:  /// removes the attribute from the list of attributes.
        -:  383:  void removeParamAttrs(unsigned ArgNo, const AttributeMask &Attrs);
        -:  384:
        -:  385:  /// Return true if the function has the attribute.
        -:  386:  bool hasFnAttribute(Attribute::AttrKind Kind) const;
        -:  387:
        -:  388:  /// Return true if the function has the attribute.
        -:  389:  bool hasFnAttribute(StringRef Kind) const;
        -:  390:
        -:  391:  /// check if an attribute is in the list of attributes for the return value.
        -:  392:  bool hasRetAttribute(Attribute::AttrKind Kind) const;
        -:  393:
        -:  394:  /// check if an attributes is in the list of attributes.
        -:  395:  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;
        -:  396:
        -:  397:  /// gets the attribute from the list of attributes.
        -:  398:  Attribute getAttributeAtIndex(unsigned i, Attribute::AttrKind Kind) const;
        -:  399:
        -:  400:  /// gets the attribute from the list of attributes.
        -:  401:  Attribute getAttributeAtIndex(unsigned i, StringRef Kind) const;
        -:  402:
        -:  403:  /// Return the attribute for the given attribute kind.
        -:  404:  Attribute getFnAttribute(Attribute::AttrKind Kind) const;
        -:  405:
        -:  406:  /// Return the attribute for the given attribute kind.
        -:  407:  Attribute getFnAttribute(StringRef Kind) const;
        -:  408:
        -:  409:  /// gets the specified attribute from the list of attributes.
        -:  410:  Attribute getParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;
        -:  411:
        -:  412:  /// removes noundef and other attributes that imply undefined behavior if a
        -:  413:  /// `undef` or `poison` value is passed from the list of attributes.
        -:  414:  void removeParamUndefImplyingAttrs(unsigned ArgNo);
        -:  415:
        -:  416:  /// Return the stack alignment for the function.
        -:  417:  MaybeAlign getFnStackAlign() const {
        -:  418:    return AttributeSets.getFnStackAlignment();
        -:  419:  }
        -:  420:
        -:  421:  /// Returns true if the function has ssp, sspstrong, or sspreq fn attrs.
        -:  422:  bool hasStackProtectorFnAttr() const;
        -:  423:
        -:  424:  /// adds the dereferenceable attribute to the list of attributes for
        -:  425:  /// the given arg.
        -:  426:  void addDereferenceableParamAttr(unsigned ArgNo, uint64_t Bytes);
        -:  427:
        -:  428:  /// adds the dereferenceable_or_null attribute to the list of
        -:  429:  /// attributes for the given arg.
        -:  430:  void addDereferenceableOrNullParamAttr(unsigned ArgNo, uint64_t Bytes);
        -:  431:
        -:  432:  /// Extract the alignment for a call or parameter (0=unknown).
        -:  433:  /// FIXME: Remove this function once transition to Align is over.
        -:  434:  /// Use getParamAlign() instead.
        -:  435:  uint64_t getParamAlignment(unsigned ArgNo) const {
        -:  436:    if (const auto MA = getParamAlign(ArgNo))
        -:  437:      return MA->value();
        -:  438:    return 0;
        -:  439:  }
        -:  440:
        -:  441:  MaybeAlign getParamAlign(unsigned ArgNo) const {
        -:  442:    return AttributeSets.getParamAlignment(ArgNo);
        -:  443:  }
        -:  444:
        -:  445:  MaybeAlign getParamStackAlign(unsigned ArgNo) const {
        -:  446:    return AttributeSets.getParamStackAlignment(ArgNo);
        -:  447:  }
        -:  448:
        -:  449:  /// Extract the byval type for a parameter.
        -:  450:  Type *getParamByValType(unsigned ArgNo) const {
        -:  451:    return AttributeSets.getParamByValType(ArgNo);
        -:  452:  }
        -:  453:
        -:  454:  /// Extract the sret type for a parameter.
        -:  455:  Type *getParamStructRetType(unsigned ArgNo) const {
        -:  456:    return AttributeSets.getParamStructRetType(ArgNo);
        -:  457:  }
        -:  458:
        -:  459:  /// Extract the inalloca type for a parameter.
        -:  460:  Type *getParamInAllocaType(unsigned ArgNo) const {
        -:  461:    return AttributeSets.getParamInAllocaType(ArgNo);
        -:  462:  }
        -:  463:
        -:  464:  /// Extract the byref type for a parameter.
        -:  465:  Type *getParamByRefType(unsigned ArgNo) const {
        -:  466:    return AttributeSets.getParamByRefType(ArgNo);
        -:  467:  }
        -:  468:
        -:  469:  /// Extract the preallocated type for a parameter.
        -:  470:  Type *getParamPreallocatedType(unsigned ArgNo) const {
        -:  471:    return AttributeSets.getParamPreallocatedType(ArgNo);
        -:  472:  }
        -:  473:
        -:  474:  /// Extract the number of dereferenceable bytes for a parameter.
        -:  475:  /// @param ArgNo Index of an argument, with 0 being the first function arg.
        -:  476:  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {
        -:  477:    return AttributeSets.getParamDereferenceableBytes(ArgNo);
        -:  478:  }
        -:  479:
        -:  480:  /// Extract the number of dereferenceable_or_null bytes for a
        -:  481:  /// parameter.
        -:  482:  /// @param ArgNo AttributeList ArgNo, referring to an argument.
        -:  483:  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {
        -:  484:    return AttributeSets.getParamDereferenceableOrNullBytes(ArgNo);
        -:  485:  }
        -:  486:
        -:  487:  /// Determine if the function is presplit coroutine.
        -:  488:  bool isPresplitCoroutine() const {
        -:  489:    return hasFnAttribute(Attribute::PresplitCoroutine);
        -:  490:  }
        -:  491:  void setPresplitCoroutine() { addFnAttr(Attribute::PresplitCoroutine); }
        -:  492:  void setSplittedCoroutine() { removeFnAttr(Attribute::PresplitCoroutine); }
        -:  493:
        -:  494:  /// Determine if the function does not access memory.
        -:  495:  bool doesNotAccessMemory() const {
        -:  496:    return hasFnAttribute(Attribute::ReadNone);
        -:  497:  }
        -:  498:  void setDoesNotAccessMemory() {
        -:  499:    addFnAttr(Attribute::ReadNone);
        -:  500:  }
        -:  501:
        -:  502:  /// Determine if the function does not access or only reads memory.
        -:  503:  bool onlyReadsMemory() const {
        -:  504:    return doesNotAccessMemory() || hasFnAttribute(Attribute::ReadOnly);
        -:  505:  }
        -:  506:  void setOnlyReadsMemory() {
        -:  507:    addFnAttr(Attribute::ReadOnly);
        -:  508:  }
        -:  509:
        -:  510:  /// Determine if the function does not access or only writes memory.
        -:  511:  bool onlyWritesMemory() const {
        -:  512:    return doesNotAccessMemory() || hasFnAttribute(Attribute::WriteOnly);
        -:  513:  }
        -:  514:  void setOnlyWritesMemory() {
        -:  515:    addFnAttr(Attribute::WriteOnly);
        -:  516:  }
        -:  517:
        -:  518:  /// Determine if the call can access memmory only using pointers based
        -:  519:  /// on its arguments.
        -:  520:  bool onlyAccessesArgMemory() const {
        -:  521:    return hasFnAttribute(Attribute::ArgMemOnly);
        -:  522:  }
        -:  523:  void setOnlyAccessesArgMemory() { addFnAttr(Attribute::ArgMemOnly); }
        -:  524:
        -:  525:  /// Determine if the function may only access memory that is
        -:  526:  ///  inaccessible from the IR.
        -:  527:  bool onlyAccessesInaccessibleMemory() const {
        -:  528:    return hasFnAttribute(Attribute::InaccessibleMemOnly);
        -:  529:  }
        -:  530:  void setOnlyAccessesInaccessibleMemory() {
        -:  531:    addFnAttr(Attribute::InaccessibleMemOnly);
        -:  532:  }
        -:  533:
        -:  534:  /// Determine if the function may only access memory that is
        -:  535:  ///  either inaccessible from the IR or pointed to by its arguments.
        -:  536:  bool onlyAccessesInaccessibleMemOrArgMem() const {
        -:  537:    return hasFnAttribute(Attribute::InaccessibleMemOrArgMemOnly);
        -:  538:  }
        -:  539:  void setOnlyAccessesInaccessibleMemOrArgMem() {
        -:  540:    addFnAttr(Attribute::InaccessibleMemOrArgMemOnly);
        -:  541:  }
        -:  542:
        -:  543:  /// Determine if the function cannot return.
        -:  544:  bool doesNotReturn() const {
        -:  545:    return hasFnAttribute(Attribute::NoReturn);
        -:  546:  }
        -:  547:  void setDoesNotReturn() {
        -:  548:    addFnAttr(Attribute::NoReturn);
        -:  549:  }
        -:  550:
        -:  551:  /// Determine if the function should not perform indirect branch tracking.
        -:  552:  bool doesNoCfCheck() const { return hasFnAttribute(Attribute::NoCfCheck); }
        -:  553:
        -:  554:  /// Determine if the function cannot unwind.
        -:  555:  bool doesNotThrow() const {
        -:  556:    return hasFnAttribute(Attribute::NoUnwind);
        -:  557:  }
        -:  558:  void setDoesNotThrow() {
        -:  559:    addFnAttr(Attribute::NoUnwind);
        -:  560:  }
        -:  561:
        -:  562:  /// Determine if the call cannot be duplicated.
        -:  563:  bool cannotDuplicate() const {
        -:  564:    return hasFnAttribute(Attribute::NoDuplicate);
        -:  565:  }
        -:  566:  void setCannotDuplicate() {
        -:  567:    addFnAttr(Attribute::NoDuplicate);
        -:  568:  }
        -:  569:
        -:  570:  /// Determine if the call is convergent.
        -:  571:  bool isConvergent() const {
        -:  572:    return hasFnAttribute(Attribute::Convergent);
        -:  573:  }
        -:  574:  void setConvergent() {
        -:  575:    addFnAttr(Attribute::Convergent);
        -:  576:  }
        -:  577:  void setNotConvergent() {
        -:  578:    removeFnAttr(Attribute::Convergent);
        -:  579:  }
        -:  580:
        -:  581:  /// Determine if the call has sideeffects.
        -:  582:  bool isSpeculatable() const {
        -:  583:    return hasFnAttribute(Attribute::Speculatable);
        -:  584:  }
        -:  585:  void setSpeculatable() {
        -:  586:    addFnAttr(Attribute::Speculatable);
        -:  587:  }
        -:  588:
        -:  589:  /// Determine if the call might deallocate memory.
        -:  590:  bool doesNotFreeMemory() const {
        -:  591:    return onlyReadsMemory() || hasFnAttribute(Attribute::NoFree);
        -:  592:  }
        -:  593:  void setDoesNotFreeMemory() {
        -:  594:    addFnAttr(Attribute::NoFree);
        -:  595:  }
        -:  596:
        -:  597:  /// Determine if the call can synchroize with other threads
        -:  598:  bool hasNoSync() const {
        -:  599:    return hasFnAttribute(Attribute::NoSync);
        -:  600:  }
        -:  601:  void setNoSync() {
        -:  602:    addFnAttr(Attribute::NoSync);
        -:  603:  }
        -:  604:
        -:  605:  /// Determine if the function is known not to recurse, directly or
        -:  606:  /// indirectly.
        -:  607:  bool doesNotRecurse() const {
        -:  608:    return hasFnAttribute(Attribute::NoRecurse);
        -:  609:  }
        -:  610:  void setDoesNotRecurse() {
        -:  611:    addFnAttr(Attribute::NoRecurse);
        -:  612:  }
        -:  613:
        -:  614:  /// Determine if the function is required to make forward progress.
        -:  615:  bool mustProgress() const {
        -:  616:    return hasFnAttribute(Attribute::MustProgress) ||
        -:  617:           hasFnAttribute(Attribute::WillReturn);
        -:  618:  }
        -:  619:  void setMustProgress() { addFnAttr(Attribute::MustProgress); }
        -:  620:
        -:  621:  /// Determine if the function will return.
        -:  622:  bool willReturn() const { return hasFnAttribute(Attribute::WillReturn); }
        -:  623:  void setWillReturn() { addFnAttr(Attribute::WillReturn); }
        -:  624:
        -:  625:  /// Get what kind of unwind table entry to generate for this function.
        -:  626:  UWTableKind getUWTableKind() const {
        -:  627:    return AttributeSets.getUWTableKind();
        -:  628:  }
        -:  629:
        -:  630:  /// True if the ABI mandates (or the user requested) that this
        -:  631:  /// function be in a unwind table.
        -:  632:  bool hasUWTable() const {
        -:  633:    return getUWTableKind() != UWTableKind::None;
        -:  634:  }
        -:  635:  void setUWTableKind(UWTableKind K) {
        -:  636:    addFnAttr(Attribute::getWithUWTableKind(getContext(), K));
        -:  637:  }
        -:  638:  /// True if this function needs an unwind table.
        -:  639:  bool needsUnwindTableEntry() const {
        -:  640:    return hasUWTable() || !doesNotThrow() || hasPersonalityFn();
        -:  641:  }
        -:  642:
        -:  643:  /// Determine if the function returns a structure through first
        -:  644:  /// or second pointer argument.
        -:  645:  bool hasStructRetAttr() const {
        -:  646:    return AttributeSets.hasParamAttr(0, Attribute::StructRet) ||
        -:  647:           AttributeSets.hasParamAttr(1, Attribute::StructRet);
        -:  648:  }
        -:  649:
        -:  650:  /// Determine if the parameter or return value is marked with NoAlias
        -:  651:  /// attribute.
        -:  652:  bool returnDoesNotAlias() const {
        -:  653:    return AttributeSets.hasRetAttr(Attribute::NoAlias);
        -:  654:  }
        -:  655:  void setReturnDoesNotAlias() { addRetAttr(Attribute::NoAlias); }
        -:  656:
        -:  657:  /// Do not optimize this function (-O0).
        -:  658:  bool hasOptNone() const { return hasFnAttribute(Attribute::OptimizeNone); }
        -:  659:
        -:  660:  /// Optimize this function for minimum size (-Oz).
        -:  661:  bool hasMinSize() const { return hasFnAttribute(Attribute::MinSize); }
        -:  662:
        -:  663:  /// Optimize this function for size (-Os) or minimum size (-Oz).
        -:  664:  bool hasOptSize() const {
        -:  665:    return hasFnAttribute(Attribute::OptimizeForSize) || hasMinSize();
        -:  666:  }
        -:  667:
        -:  668:  /// Returns the denormal handling type for the default rounding mode of the
        -:  669:  /// function.
        -:  670:  DenormalMode getDenormalMode(const fltSemantics &FPType) const;
        -:  671:
        -:  672:  /// copyAttributesFrom - copy all additional attributes (those not needed to
        -:  673:  /// create a Function) from the Function Src to this one.
        -:  674:  void copyAttributesFrom(const Function *Src);
        -:  675:
        -:  676:  /// deleteBody - This method deletes the body of the function, and converts
        -:  677:  /// the linkage to external.
        -:  678:  ///
        -:  679:  void deleteBody() {
        -:  680:    dropAllReferences();
        -:  681:    setLinkage(ExternalLinkage);
        -:  682:  }
        -:  683:
        -:  684:  /// removeFromParent - This method unlinks 'this' from the containing module,
        -:  685:  /// but does not delete it.
        -:  686:  ///
        -:  687:  void removeFromParent();
        -:  688:
        -:  689:  /// eraseFromParent - This method unlinks 'this' from the containing module
        -:  690:  /// and deletes it.
        -:  691:  ///
        -:  692:  void eraseFromParent();
        -:  693:
        -:  694:  /// Steal arguments from another function.
        -:  695:  ///
        -:  696:  /// Drop this function's arguments and splice in the ones from \c Src.
        -:  697:  /// Requires that this has no function body.
        -:  698:  void stealArgumentListFrom(Function &Src);
        -:  699:
        -:  700:  /// Get the underlying elements of the Function... the basic block list is
        -:  701:  /// empty for external functions.
        -:  702:  ///
        -:  703:  const BasicBlockListType &getBasicBlockList() const { return BasicBlocks; }
        -:  704:        BasicBlockListType &getBasicBlockList()       { return BasicBlocks; }
        -:  705:
        -:  706:  static BasicBlockListType Function::*getSublistAccess(BasicBlock*) {
        -:  707:    return &Function::BasicBlocks;
        -:  708:  }
        -:  709:
        -:  710:  const BasicBlock       &getEntryBlock() const   { return front(); }
        -:  711:        BasicBlock       &getEntryBlock()         { return front(); }
        -:  712:
        -:  713:  //===--------------------------------------------------------------------===//
        -:  714:  // Symbol Table Accessing functions...
        -:  715:
        -:  716:  /// getSymbolTable() - Return the symbol table if any, otherwise nullptr.
        -:  717:  ///
        -:  718:  inline ValueSymbolTable *getValueSymbolTable() { return SymTab.get(); }
        -:  719:  inline const ValueSymbolTable *getValueSymbolTable() const {
        -:  720:    return SymTab.get();
        -:  721:  }
        -:  722:
        -:  723:  //===--------------------------------------------------------------------===//
        -:  724:  // BasicBlock iterator forwarding functions
        -:  725:  //
        -:  726:  iterator                begin()       { return BasicBlocks.begin(); }
        -:  727:  const_iterator          begin() const { return BasicBlocks.begin(); }
        -:  728:  iterator                end  ()       { return BasicBlocks.end();   }
        -:  729:  const_iterator          end  () const { return BasicBlocks.end();   }
        -:  730:
        -:  731:  size_t                   size() const { return BasicBlocks.size();  }
        -:  732:  bool                    empty() const { return BasicBlocks.empty(); }
        -:  733:  const BasicBlock       &front() const { return BasicBlocks.front(); }
        -:  734:        BasicBlock       &front()       { return BasicBlocks.front(); }
        -:  735:  const BasicBlock        &back() const { return BasicBlocks.back();  }
        -:  736:        BasicBlock        &back()       { return BasicBlocks.back();  }
        -:  737:
        -:  738:/// @name Function Argument Iteration
        -:  739:/// @{
        -:  740:
        -:  741:  arg_iterator arg_begin() {
        -:  742:    CheckLazyArguments();
        -:  743:    return Arguments;
        -:  744:  }
        -:  745:  const_arg_iterator arg_begin() const {
        -:  746:    CheckLazyArguments();
        -:  747:    return Arguments;
        -:  748:  }
        -:  749:
        -:  750:  arg_iterator arg_end() {
        -:  751:    CheckLazyArguments();
        -:  752:    return Arguments + NumArgs;
        -:  753:  }
        -:  754:  const_arg_iterator arg_end() const {
        -:  755:    CheckLazyArguments();
        -:  756:    return Arguments + NumArgs;
        -:  757:  }
        -:  758:
        -:  759:  Argument* getArg(unsigned i) const {
        -:  760:    assert (i < NumArgs && "getArg() out of range!");
        -:  761:    CheckLazyArguments();
        -:  762:    return Arguments + i;
        -:  763:  }
        -:  764:
        -:  765:  iterator_range<arg_iterator> args() {
        -:  766:    return make_range(arg_begin(), arg_end());
        -:  767:  }
        -:  768:  iterator_range<const_arg_iterator> args() const {
        -:  769:    return make_range(arg_begin(), arg_end());
        -:  770:  }
        -:  771:
        -:  772:/// @}
        -:  773:
        -:  774:  size_t arg_size() const { return NumArgs; }
        -:  775:  bool arg_empty() const { return arg_size() == 0; }
        -:  776:
        -:  777:  /// Check whether this function has a personality function.
        -:  778:  bool hasPersonalityFn() const {
        -:  779:    return getSubclassDataFromValue() & (1<<3);
        -:  780:  }
        -:  781:
        -:  782:  /// Get the personality function associated with this function.
        -:  783:  Constant *getPersonalityFn() const;
        -:  784:  void setPersonalityFn(Constant *Fn);
        -:  785:
        -:  786:  /// Check whether this function has prefix data.
        -:  787:  bool hasPrefixData() const {
        -:  788:    return getSubclassDataFromValue() & (1<<1);
        -:  789:  }
        -:  790:
        -:  791:  /// Get the prefix data associated with this function.
        -:  792:  Constant *getPrefixData() const;
        -:  793:  void setPrefixData(Constant *PrefixData);
        -:  794:
        -:  795:  /// Check whether this function has prologue data.
        -:  796:  bool hasPrologueData() const {
        -:  797:    return getSubclassDataFromValue() & (1<<2);
        -:  798:  }
        -:  799:
        -:  800:  /// Get the prologue data associated with this function.
        -:  801:  Constant *getPrologueData() const;
        -:  802:  void setPrologueData(Constant *PrologueData);
        -:  803:
        -:  804:  /// Print the function to an output stream with an optional
        -:  805:  /// AssemblyAnnotationWriter.
        -:  806:  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,
        -:  807:             bool ShouldPreserveUseListOrder = false,
        -:  808:             bool IsForDebug = false) const;
        -:  809:
        -:  810:  /// viewCFG - This function is meant for use from the debugger.  You can just
        -:  811:  /// say 'call F->viewCFG()' and a ghostview window should pop up from the
        -:  812:  /// program, displaying the CFG of the current function with the code for each
        -:  813:  /// basic block inside.  This depends on there being a 'dot' and 'gv' program
        -:  814:  /// in your path.
        -:  815:  ///
        -:  816:  void viewCFG() const;
        -:  817:
        -:  818:  /// Extended form to print edge weights.
        -:  819:  void viewCFG(bool ViewCFGOnly, const BlockFrequencyInfo *BFI,
        -:  820:               const BranchProbabilityInfo *BPI) const;
        -:  821:
        -:  822:  /// viewCFGOnly - This function is meant for use from the debugger.  It works
        -:  823:  /// just like viewCFG, but it does not include the contents of basic blocks
        -:  824:  /// into the nodes, just the label.  If you are only interested in the CFG
        -:  825:  /// this can make the graph smaller.
        -:  826:  ///
        -:  827:  void viewCFGOnly() const;
        -:  828:
        -:  829:  /// Extended form to print edge weights.
        -:  830:  void viewCFGOnly(const BlockFrequencyInfo *BFI,
        -:  831:                   const BranchProbabilityInfo *BPI) const;
        -:  832:
        -:  833:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  834:  static bool classof(const Value *V) {
        -:  835:    return V->getValueID() == Value::FunctionVal;
        -:  836:  }
        -:  837:
        -:  838:  /// dropAllReferences() - This method causes all the subinstructions to "let
        -:  839:  /// go" of all references that they are maintaining.  This allows one to
        -:  840:  /// 'delete' a whole module at a time, even though there may be circular
        -:  841:  /// references... first all references are dropped, and all use counts go to
        -:  842:  /// zero.  Then everything is deleted for real.  Note that no operations are
        -:  843:  /// valid on an object that has "dropped all references", except operator
        -:  844:  /// delete.
        -:  845:  ///
        -:  846:  /// Since no other object in the module can have references into the body of a
        -:  847:  /// function, dropping all references deletes the entire body of the function,
        -:  848:  /// including any contained basic blocks.
        -:  849:  ///
        -:  850:  void dropAllReferences();
        -:  851:
        -:  852:  /// hasAddressTaken - returns true if there are any uses of this function
        -:  853:  /// other than direct calls or invokes to it, or blockaddress expressions.
        -:  854:  /// Optionally passes back an offending user for diagnostic purposes,
        -:  855:  /// ignores callback uses, assume like pointer annotation calls, references in
        -:  856:  /// llvm.used and llvm.compiler.used variables, and operand bundle
        -:  857:  /// "clang.arc.attachedcall".
        -:  858:  bool hasAddressTaken(const User ** = nullptr,
        -:  859:                       bool IgnoreCallbackUses = false,
        -:  860:                       bool IgnoreAssumeLikeCalls = true,
        -:  861:                       bool IngoreLLVMUsed = false,
        -:  862:                       bool IgnoreARCAttachedCall = false) const;
        -:  863:
        -:  864:  /// isDefTriviallyDead - Return true if it is trivially safe to remove
        -:  865:  /// this function definition from the module (because it isn't externally
        -:  866:  /// visible, does not have its address taken, and has no callers).  To make
        -:  867:  /// this more accurate, call removeDeadConstantUsers first.
        -:  868:  bool isDefTriviallyDead() const;
        -:  869:
        -:  870:  /// callsFunctionThatReturnsTwice - Return true if the function has a call to
        -:  871:  /// setjmp or other function that gcc recognizes as "returning twice".
        -:  872:  bool callsFunctionThatReturnsTwice() const;
        -:  873:
        -:  874:  /// Set the attached subprogram.
        -:  875:  ///
        -:  876:  /// Calls \a setMetadata() with \a LLVMContext::MD_dbg.
        -:  877:  void setSubprogram(DISubprogram *SP);
        -:  878:
        -:  879:  /// Get the attached subprogram.
        -:  880:  ///
        -:  881:  /// Calls \a getMetadata() with \a LLVMContext::MD_dbg and casts the result
        -:  882:  /// to \a DISubprogram.
        -:  883:  DISubprogram *getSubprogram() const;
        -:  884:
        -:  885:  /// Returns true if we should emit debug info for profiling.
        -:  886:  bool isDebugInfoForProfiling() const;
        -:  887:
        -:  888:  /// Check if null pointer dereferencing is considered undefined behavior for
        -:  889:  /// the function.
        -:  890:  /// Return value: false => null pointer dereference is undefined.
        -:  891:  /// Return value: true =>  null pointer dereference is not undefined.
        -:  892:  bool nullPointerIsDefined() const;
        -:  893:
        -:  894:private:
        -:  895:  void allocHungoffUselist();
        -:  896:  template<int Idx> void setHungoffOperand(Constant *C);
        -:  897:
        -:  898:  /// Shadow Value::setValueSubclassData with a private forwarding method so
        -:  899:  /// that subclasses cannot accidentally use it.
        -:  900:  void setValueSubclassData(unsigned short D) {
        -:  901:    Value::setValueSubclassData(D);
        -:  902:  }
        -:  903:  void setValueSubclassDataBit(unsigned Bit, bool On);
        -:  904:};
        -:  905:
        -:  906:/// Check whether null pointer dereferencing is considered undefined behavior
        -:  907:/// for a given function or an address space.
        -:  908:/// Null pointer access in non-zero address space is not considered undefined.
        -:  909:/// Return value: false => null pointer dereference is undefined.
        -:  910:/// Return value: true =>  null pointer dereference is not undefined.
        -:  911:bool NullPointerIsDefined(const Function *F, unsigned AS = 0);
        -:  912:
        -:  913:template <>
        -:  914:struct OperandTraits<Function> : public HungoffOperandTraits<3> {};
        -:  915:
        -:  916:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(Function, Value)
        -:  917:
        -:  918:} // end namespace llvm
        -:  919:
        -:  920:#endif // LLVM_IR_FUNCTION_H
