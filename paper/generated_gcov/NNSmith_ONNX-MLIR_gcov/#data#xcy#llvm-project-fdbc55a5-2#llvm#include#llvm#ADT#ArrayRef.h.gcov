        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/ADT/ArrayRef.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===- ArrayRef.h - Array Reference Wrapper ---------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#ifndef LLVM_ADT_ARRAYREF_H
        -:   10:#define LLVM_ADT_ARRAYREF_H
        -:   11:
        -:   12:#include "llvm/ADT/Hashing.h"
        -:   13:#include "llvm/ADT/None.h"
        -:   14:#include "llvm/ADT/SmallVector.h"
        -:   15:#include "llvm/ADT/STLExtras.h"
        -:   16:#include "llvm/Support/Compiler.h"
        -:   17:#include <algorithm>
        -:   18:#include <array>
        -:   19:#include <cassert>
        -:   20:#include <cstddef>
        -:   21:#include <initializer_list>
        -:   22:#include <iterator>
        -:   23:#include <memory>
        -:   24:#include <type_traits>
        -:   25:#include <vector>
        -:   26:
        -:   27:namespace llvm {
        -:   28:  template<typename T> class [[nodiscard]] MutableArrayRef;
        -:   29:
        -:   30:  /// ArrayRef - Represent a constant reference to an array (0 or more elements
        -:   31:  /// consecutively in memory), i.e. a start pointer and a length.  It allows
        -:   32:  /// various APIs to take consecutive elements easily and conveniently.
        -:   33:  ///
        -:   34:  /// This class does not own the underlying data, it is expected to be used in
        -:   35:  /// situations where the data resides in some other buffer, whose lifetime
        -:   36:  /// extends past that of the ArrayRef. For this reason, it is not in general
        -:   37:  /// safe to store an ArrayRef.
        -:   38:  ///
        -:   39:  /// This is intended to be trivially copyable, so it should be passed by
        -:   40:  /// value.
        -:   41:  template<typename T>
        -:   42:  class LLVM_GSL_POINTER [[nodiscard]] ArrayRef {
        -:   43:  public:
        -:   44:    using value_type = T;
        -:   45:    using pointer = value_type *;
        -:   46:    using const_pointer = const value_type *;
        -:   47:    using reference = value_type &;
        -:   48:    using const_reference = const value_type &;
        -:   49:    using iterator = const_pointer;
        -:   50:    using const_iterator = const_pointer;
        -:   51:    using reverse_iterator = std::reverse_iterator<iterator>;
        -:   52:    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        -:   53:    using size_type = size_t;
        -:   54:    using difference_type = ptrdiff_t;
        -:   55:
        -:   56:  private:
        -:   57:    /// The start of the array, in an external buffer.
        -:   58:    const T *Data = nullptr;
        -:   59:
        -:   60:    /// The number of elements.
        -:   61:    size_type Length = 0;
        -:   62:
        -:   63:  public:
        -:   64:    /// @name Constructors
        -:   65:    /// @{
        -:   66:
        -:   67:    /// Construct an empty ArrayRef.
    #####:   68:    /*implicit*/ ArrayRef() = default;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
        -:   69:
        -:   70:    /// Construct an empty ArrayRef from None.
    #####:   71:    /*implicit*/ ArrayRef(NoneType) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:   72:
        -:   73:    /// Construct an ArrayRef from a single element.
    #####:   74:    /*implicit*/ ArrayRef(const T &OneElt)
call    0 never executed
call    1 never executed
    #####:   75:      : Data(&OneElt), Length(1) {}
call    0 never executed
        -:   76:
        -:   77:    /// Construct an ArrayRef from a pointer and length.
    #####:   78:    /*implicit*/ ArrayRef(const T *data, size_t length)
        -:   79:      : Data(data), Length(length) {}
        -:   80:
        -:   81:    /// Construct an ArrayRef from a range.
        -:   82:    ArrayRef(const T *begin, const T *end)
        -:   83:      : Data(begin), Length(end - begin) {}
        -:   84:
        -:   85:    /// Construct an ArrayRef from a SmallVector. This is templated in order to
        -:   86:    /// avoid instantiating SmallVectorTemplateCommon<T> whenever we
        -:   87:    /// copy-construct an ArrayRef.
        -:   88:    template<typename U>
    #####:   89:    /*implicit*/ ArrayRef(const SmallVectorTemplateCommon<T, U> &Vec)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
branch 59 never executed
branch 60 never executed
branch 61 never executed
branch 62 never executed
branch 63 never executed
branch 64 never executed
branch 65 never executed
branch 66 never executed
branch 67 never executed
branch 68 never executed
branch 69 never executed
branch 70 never executed
branch 71 never executed
branch 72 never executed
branch 73 never executed
branch 74 never executed
branch 75 never executed
branch 76 never executed
branch 77 never executed
branch 78 never executed
branch 79 never executed
branch 80 never executed
branch 81 never executed
branch 82 never executed
branch 83 never executed
branch 84 never executed
branch 85 never executed
branch 86 never executed
branch 87 never executed
branch 88 never executed
branch 89 never executed
branch 90 never executed
branch 91 never executed
branch 92 never executed
branch 93 never executed
branch 94 never executed
branch 95 never executed
branch 96 never executed
branch 97 never executed
branch 98 never executed
branch 99 never executed
branch 100 never executed
branch 101 never executed
branch 102 never executed
branch 103 never executed
branch 104 never executed
branch 105 never executed
branch 106 never executed
branch 107 never executed
branch 108 never executed
branch 109 never executed
branch 110 never executed
branch 111 never executed
branch 112 never executed
branch 113 never executed
branch 114 never executed
branch 115 never executed
branch 116 never executed
branch 117 never executed
branch 118 never executed
branch 119 never executed
branch 120 never executed
branch 121 never executed
branch 122 never executed
branch 123 never executed
branch 124 never executed
branch 125 never executed
branch 126 never executed
branch 127 never executed
branch 128 never executed
branch 129 never executed
branch 130 never executed
branch 131 never executed
branch 132 never executed
branch 133 never executed
branch 134 never executed
branch 135 never executed
branch 136 never executed
branch 137 never executed
branch 138 never executed
branch 139 never executed
branch 140 never executed
branch 141 never executed
branch 142 never executed
branch 143 never executed
branch 144 never executed
branch 145 never executed
branch 146 never executed
branch 147 never executed
branch 148 never executed
branch 149 never executed
branch 150 never executed
branch 151 never executed
branch 152 never executed
branch 153 never executed
branch 154 never executed
branch 155 never executed
branch 156 never executed
branch 157 never executed
branch 158 never executed
branch 159 never executed
branch 160 never executed
branch 161 never executed
branch 162 never executed
branch 163 never executed
branch 164 never executed
branch 165 never executed
branch 166 never executed
branch 167 never executed
branch 168 never executed
branch 169 never executed
branch 170 never executed
branch 171 never executed
branch 172 never executed
branch 173 never executed
branch 174 never executed
branch 175 never executed
branch 176 never executed
branch 177 never executed
branch 178 never executed
branch 179 never executed
branch 180 never executed
branch 181 never executed
branch 182 never executed
branch 183 never executed
branch 184 never executed
branch 185 never executed
branch 186 never executed
branch 187 never executed
branch 188 never executed
branch 189 never executed
branch 190 never executed
branch 191 never executed
branch 192 never executed
branch 193 never executed
branch 194 never executed
branch 195 never executed
branch 196 never executed
branch 197 never executed
branch 198 never executed
branch 199 never executed
branch 200 never executed
branch 201 never executed
branch 202 never executed
branch 203 never executed
branch 204 never executed
branch 205 never executed
branch 206 never executed
branch 207 never executed
branch 208 never executed
branch 209 never executed
branch 210 never executed
branch 211 never executed
branch 212 never executed
branch 213 never executed
branch 214 never executed
branch 215 never executed
branch 216 never executed
branch 217 never executed
branch 218 never executed
branch 219 never executed
branch 220 never executed
branch 221 never executed
branch 222 never executed
branch 223 never executed
branch 224 never executed
branch 225 never executed
branch 226 never executed
branch 227 never executed
branch 228 never executed
branch 229 never executed
branch 230 never executed
branch 231 never executed
branch 232 never executed
branch 233 never executed
branch 234 never executed
branch 235 never executed
branch 236 never executed
branch 237 never executed
branch 238 never executed
branch 239 never executed
branch 240 never executed
branch 241 never executed
branch 242 never executed
branch 243 never executed
branch 244 never executed
branch 245 never executed
branch 246 never executed
branch 247 never executed
branch 248 never executed
branch 249 never executed
branch 250 never executed
branch 251 never executed
branch 252 never executed
branch 253 never executed
branch 254 never executed
branch 255 never executed
branch 256 never executed
branch 257 never executed
branch 258 never executed
branch 259 never executed
call   260 never executed
branch 261 never executed
branch 262 never executed
call   263 never executed
call   264 never executed
call   265 never executed
call   266 never executed
    #####:   90:      : Data(Vec.data()), Length(Vec.size()) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
branch 59 never executed
branch 60 never executed
branch 61 never executed
branch 62 never executed
branch 63 never executed
branch 64 never executed
branch 65 never executed
branch 66 never executed
branch 67 never executed
branch 68 never executed
branch 69 never executed
branch 70 never executed
branch 71 never executed
branch 72 never executed
branch 73 never executed
branch 74 never executed
branch 75 never executed
branch 76 never executed
branch 77 never executed
branch 78 never executed
branch 79 never executed
branch 80 never executed
branch 81 never executed
branch 82 never executed
branch 83 never executed
branch 84 never executed
branch 85 never executed
branch 86 never executed
branch 87 never executed
branch 88 never executed
branch 89 never executed
branch 90 never executed
branch 91 never executed
branch 92 never executed
branch 93 never executed
branch 94 never executed
branch 95 never executed
branch 96 never executed
branch 97 never executed
branch 98 never executed
branch 99 never executed
branch 100 never executed
branch 101 never executed
branch 102 never executed
branch 103 never executed
branch 104 never executed
branch 105 never executed
branch 106 never executed
branch 107 never executed
branch 108 never executed
branch 109 never executed
branch 110 never executed
branch 111 never executed
branch 112 never executed
branch 113 never executed
branch 114 never executed
branch 115 never executed
branch 116 never executed
branch 117 never executed
branch 118 never executed
branch 119 never executed
branch 120 never executed
branch 121 never executed
branch 122 never executed
branch 123 never executed
branch 124 never executed
branch 125 never executed
branch 126 never executed
branch 127 never executed
branch 128 never executed
branch 129 never executed
branch 130 never executed
branch 131 never executed
branch 132 never executed
branch 133 never executed
branch 134 never executed
branch 135 never executed
branch 136 never executed
branch 137 never executed
branch 138 never executed
branch 139 never executed
branch 140 never executed
branch 141 never executed
branch 142 never executed
branch 143 never executed
branch 144 never executed
branch 145 never executed
branch 146 never executed
branch 147 never executed
branch 148 never executed
branch 149 never executed
branch 150 never executed
branch 151 never executed
branch 152 never executed
branch 153 never executed
branch 154 never executed
branch 155 never executed
branch 156 never executed
branch 157 never executed
branch 158 never executed
branch 159 never executed
branch 160 never executed
branch 161 never executed
branch 162 never executed
branch 163 never executed
branch 164 never executed
branch 165 never executed
branch 166 never executed
branch 167 never executed
branch 168 never executed
branch 169 never executed
branch 170 never executed
branch 171 never executed
branch 172 never executed
branch 173 never executed
branch 174 never executed
branch 175 never executed
branch 176 never executed
branch 177 never executed
branch 178 never executed
branch 179 never executed
branch 180 never executed
branch 181 never executed
branch 182 never executed
branch 183 never executed
branch 184 never executed
branch 185 never executed
branch 186 never executed
branch 187 never executed
branch 188 never executed
branch 189 never executed
branch 190 never executed
branch 191 never executed
branch 192 never executed
branch 193 never executed
branch 194 never executed
branch 195 never executed
branch 196 never executed
branch 197 never executed
branch 198 never executed
branch 199 never executed
branch 200 never executed
branch 201 never executed
branch 202 never executed
branch 203 never executed
branch 204 never executed
branch 205 never executed
branch 206 never executed
branch 207 never executed
branch 208 never executed
branch 209 never executed
branch 210 never executed
branch 211 never executed
branch 212 never executed
branch 213 never executed
branch 214 never executed
branch 215 never executed
branch 216 never executed
branch 217 never executed
branch 218 never executed
branch 219 never executed
branch 220 never executed
branch 221 never executed
branch 222 never executed
branch 223 never executed
branch 224 never executed
branch 225 never executed
branch 226 never executed
branch 227 never executed
branch 228 never executed
branch 229 never executed
branch 230 never executed
branch 231 never executed
branch 232 never executed
branch 233 never executed
branch 234 never executed
branch 235 never executed
branch 236 never executed
branch 237 never executed
branch 238 never executed
branch 239 never executed
branch 240 never executed
branch 241 never executed
branch 242 never executed
branch 243 never executed
branch 244 never executed
branch 245 never executed
branch 246 never executed
branch 247 never executed
branch 248 never executed
branch 249 never executed
branch 250 never executed
branch 251 never executed
branch 252 never executed
branch 253 never executed
branch 254 never executed
branch 255 never executed
branch 256 never executed
branch 257 never executed
branch 258 never executed
branch 259 never executed
call   260 never executed
branch 261 never executed
branch 262 never executed
call   263 never executed
call   264 never executed
call   265 never executed
call   266 never executed
        -:   91:    }
        -:   92:
        -:   93:    /// Construct an ArrayRef from a std::vector.
        -:   94:    template<typename A>
        -:   95:    /*implicit*/ ArrayRef(const std::vector<T, A> &Vec)
        -:   96:      : Data(Vec.data()), Length(Vec.size()) {}
        -:   97:
        -:   98:    /// Construct an ArrayRef from a std::array
        -:   99:    template <size_t N>
        -:  100:    /*implicit*/ constexpr ArrayRef(const std::array<T, N> &Arr)
        -:  101:        : Data(Arr.data()), Length(N) {}
        -:  102:
        -:  103:    /// Construct an ArrayRef from a C array.
        -:  104:    template <size_t N>
    #####:  105:    /*implicit*/ constexpr ArrayRef(const T (&Arr)[N]) : Data(Arr), Length(N) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  106:
        -:  107:    /// Construct an ArrayRef from a std::initializer_list.
        -:  108:#if LLVM_GNUC_PREREQ(9, 0, 0)
        -:  109:// Disable gcc's warning in this constructor as it generates an enormous amount
        -:  110:// of messages. Anyone using ArrayRef should already be aware of the fact that
        -:  111:// it does not do lifetime extension.
        -:  112:#pragma GCC diagnostic push
        -:  113:#pragma GCC diagnostic ignored "-Winit-list-lifetime"
        -:  114:#endif
    #####:  115:    /*implicit*/ ArrayRef(const std::initializer_list<T> &Vec)
call    0 never executed
    #####:  116:    : Data(Vec.begin() == Vec.end() ? (T*)nullptr : Vec.begin()),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
    #####:  117:      Length(Vec.size()) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
        -:  118:#if LLVM_GNUC_PREREQ(9, 0, 0)
        -:  119:#pragma GCC diagnostic pop
        -:  120:#endif
        -:  121:
        -:  122:    /// Construct an ArrayRef<const T*> from ArrayRef<T*>. This uses SFINAE to
        -:  123:    /// ensure that only ArrayRefs of pointers can be converted.
        -:  124:    template <typename U>
        -:  125:    ArrayRef(const ArrayRef<U *> &A,
        -:  126:             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>
        -:  127:                 * = nullptr)
        -:  128:        : Data(A.data()), Length(A.size()) {}
        -:  129:
        -:  130:    /// Construct an ArrayRef<const T*> from a SmallVector<T*>. This is
        -:  131:    /// templated in order to avoid instantiating SmallVectorTemplateCommon<T>
        -:  132:    /// whenever we copy-construct an ArrayRef.
        -:  133:    template <typename U, typename DummyT>
        -:  134:    /*implicit*/ ArrayRef(
        -:  135:        const SmallVectorTemplateCommon<U *, DummyT> &Vec,
        -:  136:        std::enable_if_t<std::is_convertible<U *const *, T const *>::value> * =
        -:  137:            nullptr)
        -:  138:        : Data(Vec.data()), Length(Vec.size()) {}
        -:  139:
        -:  140:    /// Construct an ArrayRef<const T*> from std::vector<T*>. This uses SFINAE
        -:  141:    /// to ensure that only vectors of pointers can be converted.
        -:  142:    template <typename U, typename A>
        -:  143:    ArrayRef(const std::vector<U *, A> &Vec,
        -:  144:             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>
        -:  145:                 * = nullptr)
        -:  146:        : Data(Vec.data()), Length(Vec.size()) {}
        -:  147:
        -:  148:    /// @}
        -:  149:    /// @name Simple Operations
        -:  150:    /// @{
        -:  151:
    #####:  152:    iterator begin() const { return Data; }
call    0 never executed
call    1 never executed
    #####:  153:    iterator end() const { return Data + Length; }
call    0 never executed
call    1 never executed
call    2 never executed
        -:  154:
        -:  155:    reverse_iterator rbegin() const { return reverse_iterator(end()); }
        -:  156:    reverse_iterator rend() const { return reverse_iterator(begin()); }
        -:  157:
        -:  158:    /// empty - Check if the array is empty.
    #####:  159:    bool empty() const { return Length == 0; }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  160:
    #####:  161:    const T *data() const { return Data; }
        -:  162:
        -:  163:    /// size - Get the array size.
    #####:  164:    size_t size() const { return Length; }
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  165:
        -:  166:    /// front - Get the first element.
    #####:  167:    const T &front() const {
    #####:  168:      assert(!empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  169:      return Data[0];
call    0 never executed
call    1 never executed
        -:  170:    }
        -:  171:
        -:  172:    /// back - Get the last element.
        -:  173:    const T &back() const {
        -:  174:      assert(!empty());
        -:  175:      return Data[Length-1];
        -:  176:    }
        -:  177:
        -:  178:    // copy - Allocate copy in Allocator and return ArrayRef<T> to it.
        -:  179:    template <typename Allocator> MutableArrayRef<T> copy(Allocator &A) {
        -:  180:      T *Buff = A.template Allocate<T>(Length);
        -:  181:      std::uninitialized_copy(begin(), end(), Buff);
        -:  182:      return MutableArrayRef<T>(Buff, Length);
        -:  183:    }
        -:  184:
        -:  185:    /// equals - Check for element-wise equality.
        -:  186:    bool equals(ArrayRef RHS) const {
        -:  187:      if (Length != RHS.Length)
        -:  188:        return false;
        -:  189:      return std::equal(begin(), end(), RHS.begin());
        -:  190:    }
        -:  191:
        -:  192:    /// slice(n, m) - Chop off the first N elements of the array, and keep M
        -:  193:    /// elements in the array.
function _ZNK4llvm8ArrayRefIPNS_5ValueEE5sliceEmm called 0 returned 0% blocks executed 0%
    #####:  194:    ArrayRef<T> slice(size_t N, size_t M) const {
    #####:  195:      assert(N+M <= size() && "Invalid specifier");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  196:      return ArrayRef<T>(data()+N, M);
        -:  197:    }
        -:  198:
        -:  199:    /// slice(n) - Chop off the first N elements of the array.
        -:  200:    ArrayRef<T> slice(size_t N) const { return slice(N, size() - N); }
        -:  201:
        -:  202:    /// Drop the first \p N elements of the array.
function _ZNK4llvm8ArrayRefIPNS_5ValueEE10drop_frontEm called 0 returned 0% blocks executed 0%
    #####:  203:    ArrayRef<T> drop_front(size_t N = 1) const {
    #####:  204:      assert(size() >= N && "Dropping more elements than exist");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  205:      return slice(N, size() - N);
call    0 never executed
        -:  206:    }
        -:  207:
        -:  208:    /// Drop the last \p N elements of the array.
        -:  209:    ArrayRef<T> drop_back(size_t N = 1) const {
        -:  210:      assert(size() >= N && "Dropping more elements than exist");
        -:  211:      return slice(0, size() - N);
        -:  212:    }
        -:  213:
        -:  214:    /// Return a copy of *this with the first N elements satisfying the
        -:  215:    /// given predicate removed.
        -:  216:    template <class PredicateT> ArrayRef<T> drop_while(PredicateT Pred) const {
        -:  217:      return ArrayRef<T>(find_if_not(*this, Pred), end());
        -:  218:    }
        -:  219:
        -:  220:    /// Return a copy of *this with the first N elements not satisfying
        -:  221:    /// the given predicate removed.
        -:  222:    template <class PredicateT> ArrayRef<T> drop_until(PredicateT Pred) const {
        -:  223:      return ArrayRef<T>(find_if(*this, Pred), end());
        -:  224:    }
        -:  225:
        -:  226:    /// Return a copy of *this with only the first \p N elements.
        -:  227:    ArrayRef<T> take_front(size_t N = 1) const {
        -:  228:      if (N >= size())
        -:  229:        return *this;
        -:  230:      return drop_back(size() - N);
        -:  231:    }
        -:  232:
        -:  233:    /// Return a copy of *this with only the last \p N elements.
        -:  234:    ArrayRef<T> take_back(size_t N = 1) const {
        -:  235:      if (N >= size())
        -:  236:        return *this;
        -:  237:      return drop_front(size() - N);
        -:  238:    }
        -:  239:
        -:  240:    /// Return the first N elements of this Array that satisfy the given
        -:  241:    /// predicate.
        -:  242:    template <class PredicateT> ArrayRef<T> take_while(PredicateT Pred) const {
        -:  243:      return ArrayRef<T>(begin(), find_if_not(*this, Pred));
        -:  244:    }
        -:  245:
        -:  246:    /// Return the first N elements of this Array that don't satisfy the
        -:  247:    /// given predicate.
        -:  248:    template <class PredicateT> ArrayRef<T> take_until(PredicateT Pred) const {
        -:  249:      return ArrayRef<T>(begin(), find_if(*this, Pred));
        -:  250:    }
        -:  251:
        -:  252:    /// @}
        -:  253:    /// @name Operator Overloads
        -:  254:    /// @{
    #####:  255:    const T &operator[](size_t Index) const {
    #####:  256:      assert(Index < Length && "Invalid index!");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
        -:  257:      return Data[Index];
        -:  258:    }
        -:  259:
        -:  260:    /// Disallow accidental assignment from a temporary.
        -:  261:    ///
        -:  262:    /// The declaration here is extra complicated so that "arrayRef = {}"
        -:  263:    /// continues to select the move assignment operator.
        -:  264:    template <typename U>
        -:  265:    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &
        -:  266:    operator=(U &&Temporary) = delete;
        -:  267:
        -:  268:    /// Disallow accidental assignment from a temporary.
        -:  269:    ///
        -:  270:    /// The declaration here is extra complicated so that "arrayRef = {}"
        -:  271:    /// continues to select the move assignment operator.
        -:  272:    template <typename U>
        -:  273:    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &
        -:  274:    operator=(std::initializer_list<U>) = delete;
        -:  275:
        -:  276:    /// @}
        -:  277:    /// @name Expensive Operations
        -:  278:    /// @{
        -:  279:    std::vector<T> vec() const {
        -:  280:      return std::vector<T>(Data, Data+Length);
        -:  281:    }
        -:  282:
        -:  283:    /// @}
        -:  284:    /// @name Conversion operators
        -:  285:    /// @{
        -:  286:    operator std::vector<T>() const {
        -:  287:      return std::vector<T>(Data, Data+Length);
        -:  288:    }
        -:  289:
        -:  290:    /// @}
        -:  291:  };
        -:  292:
        -:  293:  /// MutableArrayRef - Represent a mutable reference to an array (0 or more
        -:  294:  /// elements consecutively in memory), i.e. a start pointer and a length.  It
        -:  295:  /// allows various APIs to take and modify consecutive elements easily and
        -:  296:  /// conveniently.
        -:  297:  ///
        -:  298:  /// This class does not own the underlying data, it is expected to be used in
        -:  299:  /// situations where the data resides in some other buffer, whose lifetime
        -:  300:  /// extends past that of the MutableArrayRef. For this reason, it is not in
        -:  301:  /// general safe to store a MutableArrayRef.
        -:  302:  ///
        -:  303:  /// This is intended to be trivially copyable, so it should be passed by
        -:  304:  /// value.
        -:  305:  template<typename T>
        -:  306:  class [[nodiscard]] MutableArrayRef : public ArrayRef<T> {
        -:  307:  public:
        -:  308:    using value_type = T;
        -:  309:    using pointer = value_type *;
        -:  310:    using const_pointer = const value_type *;
        -:  311:    using reference = value_type &;
        -:  312:    using const_reference = const value_type &;
        -:  313:    using iterator = pointer;
        -:  314:    using const_iterator = const_pointer;
        -:  315:    using reverse_iterator = std::reverse_iterator<iterator>;
        -:  316:    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        -:  317:    using size_type = size_t;
        -:  318:    using difference_type = ptrdiff_t;
        -:  319:
        -:  320:    /// Construct an empty MutableArrayRef.
    #####:  321:    /*implicit*/ MutableArrayRef() = default;
        -:  322:
        -:  323:    /// Construct an empty MutableArrayRef from None.
        -:  324:    /*implicit*/ MutableArrayRef(NoneType) : ArrayRef<T>() {}
        -:  325:
        -:  326:    /// Construct a MutableArrayRef from a single element.
        -:  327:    /*implicit*/ MutableArrayRef(T &OneElt) : ArrayRef<T>(OneElt) {}
        -:  328:
        -:  329:    /// Construct a MutableArrayRef from a pointer and length.
    #####:  330:    /*implicit*/ MutableArrayRef(T *data, size_t length)
    #####:  331:      : ArrayRef<T>(data, length) {}
branch  0 never executed
branch  1 never executed
        -:  332:
        -:  333:    /// Construct a MutableArrayRef from a range.
        -:  334:    MutableArrayRef(T *begin, T *end) : ArrayRef<T>(begin, end) {}
        -:  335:
        -:  336:    /// Construct a MutableArrayRef from a SmallVector.
        -:  337:    /*implicit*/ MutableArrayRef(SmallVectorImpl<T> &Vec)
        -:  338:    : ArrayRef<T>(Vec) {}
        -:  339:
        -:  340:    /// Construct a MutableArrayRef from a std::vector.
        -:  341:    /*implicit*/ MutableArrayRef(std::vector<T> &Vec)
        -:  342:    : ArrayRef<T>(Vec) {}
        -:  343:
        -:  344:    /// Construct a MutableArrayRef from a std::array
        -:  345:    template <size_t N>
        -:  346:    /*implicit*/ constexpr MutableArrayRef(std::array<T, N> &Arr)
        -:  347:        : ArrayRef<T>(Arr) {}
        -:  348:
        -:  349:    /// Construct a MutableArrayRef from a C array.
        -:  350:    template <size_t N>
        -:  351:    /*implicit*/ constexpr MutableArrayRef(T (&Arr)[N]) : ArrayRef<T>(Arr) {}
        -:  352:
    #####:  353:    T *data() const { return const_cast<T*>(ArrayRef<T>::data()); }
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
call   129 never executed
call   130 never executed
call   131 never executed
call   132 never executed
call   133 never executed
        -:  354:
    #####:  355:    iterator begin() const { return data(); }
    #####:  356:    iterator end() const { return data() + this->size(); }
        -:  357:
        -:  358:    reverse_iterator rbegin() const { return reverse_iterator(end()); }
        -:  359:    reverse_iterator rend() const { return reverse_iterator(begin()); }
        -:  360:
        -:  361:    /// front - Get the first element.
        -:  362:    T &front() const {
        -:  363:      assert(!this->empty());
        -:  364:      return data()[0];
        -:  365:    }
        -:  366:
        -:  367:    /// back - Get the last element.
        -:  368:    T &back() const {
        -:  369:      assert(!this->empty());
        -:  370:      return data()[this->size()-1];
        -:  371:    }
        -:  372:
        -:  373:    /// slice(n, m) - Chop off the first N elements of the array, and keep M
        -:  374:    /// elements in the array.
        -:  375:    MutableArrayRef<T> slice(size_t N, size_t M) const {
        -:  376:      assert(N + M <= this->size() && "Invalid specifier");
        -:  377:      return MutableArrayRef<T>(this->data() + N, M);
        -:  378:    }
        -:  379:
        -:  380:    /// slice(n) - Chop off the first N elements of the array.
        -:  381:    MutableArrayRef<T> slice(size_t N) const {
        -:  382:      return slice(N, this->size() - N);
        -:  383:    }
        -:  384:
        -:  385:    /// Drop the first \p N elements of the array.
        -:  386:    MutableArrayRef<T> drop_front(size_t N = 1) const {
        -:  387:      assert(this->size() >= N && "Dropping more elements than exist");
        -:  388:      return slice(N, this->size() - N);
        -:  389:    }
        -:  390:
        -:  391:    MutableArrayRef<T> drop_back(size_t N = 1) const {
        -:  392:      assert(this->size() >= N && "Dropping more elements than exist");
        -:  393:      return slice(0, this->size() - N);
        -:  394:    }
        -:  395:
        -:  396:    /// Return a copy of *this with the first N elements satisfying the
        -:  397:    /// given predicate removed.
        -:  398:    template <class PredicateT>
        -:  399:    MutableArrayRef<T> drop_while(PredicateT Pred) const {
        -:  400:      return MutableArrayRef<T>(find_if_not(*this, Pred), end());
        -:  401:    }
        -:  402:
        -:  403:    /// Return a copy of *this with the first N elements not satisfying
        -:  404:    /// the given predicate removed.
        -:  405:    template <class PredicateT>
        -:  406:    MutableArrayRef<T> drop_until(PredicateT Pred) const {
        -:  407:      return MutableArrayRef<T>(find_if(*this, Pred), end());
        -:  408:    }
        -:  409:
        -:  410:    /// Return a copy of *this with only the first \p N elements.
        -:  411:    MutableArrayRef<T> take_front(size_t N = 1) const {
        -:  412:      if (N >= this->size())
        -:  413:        return *this;
        -:  414:      return drop_back(this->size() - N);
        -:  415:    }
        -:  416:
        -:  417:    /// Return a copy of *this with only the last \p N elements.
        -:  418:    MutableArrayRef<T> take_back(size_t N = 1) const {
        -:  419:      if (N >= this->size())
        -:  420:        return *this;
        -:  421:      return drop_front(this->size() - N);
        -:  422:    }
        -:  423:
        -:  424:    /// Return the first N elements of this Array that satisfy the given
        -:  425:    /// predicate.
        -:  426:    template <class PredicateT>
        -:  427:    MutableArrayRef<T> take_while(PredicateT Pred) const {
        -:  428:      return MutableArrayRef<T>(begin(), find_if_not(*this, Pred));
        -:  429:    }
        -:  430:
        -:  431:    /// Return the first N elements of this Array that don't satisfy the
        -:  432:    /// given predicate.
        -:  433:    template <class PredicateT>
        -:  434:    MutableArrayRef<T> take_until(PredicateT Pred) const {
        -:  435:      return MutableArrayRef<T>(begin(), find_if(*this, Pred));
        -:  436:    }
        -:  437:
        -:  438:    /// @}
        -:  439:    /// @name Operator Overloads
        -:  440:    /// @{
    #####:  441:    T &operator[](size_t Index) const {
    #####:  442:      assert(Index < this->size() && "Invalid index!");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
    #####:  443:      return data()[Index];
call    0 never executed
        -:  444:    }
        -:  445:  };
        -:  446:
        -:  447:  /// This is a MutableArrayRef that owns its array.
        -:  448:  template <typename T> class OwningArrayRef : public MutableArrayRef<T> {
        -:  449:  public:
        -:  450:    OwningArrayRef() = default;
        -:  451:    OwningArrayRef(size_t Size) : MutableArrayRef<T>(new T[Size], Size) {}
        -:  452:
        -:  453:    OwningArrayRef(ArrayRef<T> Data)
        -:  454:        : MutableArrayRef<T>(new T[Data.size()], Data.size()) {
        -:  455:      std::copy(Data.begin(), Data.end(), this->begin());
        -:  456:    }
        -:  457:
        -:  458:    OwningArrayRef(OwningArrayRef &&Other) { *this = std::move(Other); }
        -:  459:
        -:  460:    OwningArrayRef &operator=(OwningArrayRef &&Other) {
        -:  461:      delete[] this->data();
        -:  462:      this->MutableArrayRef<T>::operator=(Other);
        -:  463:      Other.MutableArrayRef<T>::operator=(MutableArrayRef<T>());
        -:  464:      return *this;
        -:  465:    }
        -:  466:
        -:  467:    ~OwningArrayRef() { delete[] this->data(); }
        -:  468:  };
        -:  469:
        -:  470:  /// @name ArrayRef Convenience constructors
        -:  471:  /// @{
        -:  472:
        -:  473:  /// Construct an ArrayRef from a single element.
        -:  474:  template<typename T>
        -:  475:  ArrayRef<T> makeArrayRef(const T &OneElt) {
        -:  476:    return OneElt;
        -:  477:  }
        -:  478:
        -:  479:  /// Construct an ArrayRef from a pointer and length.
        -:  480:  template<typename T>
        -:  481:  ArrayRef<T> makeArrayRef(const T *data, size_t length) {
        -:  482:    return ArrayRef<T>(data, length);
        -:  483:  }
        -:  484:
        -:  485:  /// Construct an ArrayRef from a range.
        -:  486:  template<typename T>
        -:  487:  ArrayRef<T> makeArrayRef(const T *begin, const T *end) {
        -:  488:    return ArrayRef<T>(begin, end);
        -:  489:  }
        -:  490:
        -:  491:  /// Construct an ArrayRef from a SmallVector.
        -:  492:  template <typename T>
        -:  493:  ArrayRef<T> makeArrayRef(const SmallVectorImpl<T> &Vec) {
        -:  494:    return Vec;
        -:  495:  }
        -:  496:
        -:  497:  /// Construct an ArrayRef from a SmallVector.
        -:  498:  template <typename T, unsigned N>
        -:  499:  ArrayRef<T> makeArrayRef(const SmallVector<T, N> &Vec) {
        -:  500:    return Vec;
        -:  501:  }
        -:  502:
        -:  503:  /// Construct an ArrayRef from a std::vector.
        -:  504:  template<typename T>
        -:  505:  ArrayRef<T> makeArrayRef(const std::vector<T> &Vec) {
        -:  506:    return Vec;
        -:  507:  }
        -:  508:
        -:  509:  /// Construct an ArrayRef from a std::array.
        -:  510:  template <typename T, std::size_t N>
        -:  511:  ArrayRef<T> makeArrayRef(const std::array<T, N> &Arr) {
        -:  512:    return Arr;
        -:  513:  }
        -:  514:
        -:  515:  /// Construct an ArrayRef from an ArrayRef (no-op) (const)
        -:  516:  template <typename T> ArrayRef<T> makeArrayRef(const ArrayRef<T> &Vec) {
        -:  517:    return Vec;
        -:  518:  }
        -:  519:
        -:  520:  /// Construct an ArrayRef from an ArrayRef (no-op)
        -:  521:  template <typename T> ArrayRef<T> &makeArrayRef(ArrayRef<T> &Vec) {
        -:  522:    return Vec;
        -:  523:  }
        -:  524:
        -:  525:  /// Construct an ArrayRef from a C array.
        -:  526:  template<typename T, size_t N>
        -:  527:  ArrayRef<T> makeArrayRef(const T (&Arr)[N]) {
        -:  528:    return ArrayRef<T>(Arr);
        -:  529:  }
        -:  530:
        -:  531:  /// Construct a MutableArrayRef from a single element.
        -:  532:  template<typename T>
        -:  533:  MutableArrayRef<T> makeMutableArrayRef(T &OneElt) {
        -:  534:    return OneElt;
        -:  535:  }
        -:  536:
        -:  537:  /// Construct a MutableArrayRef from a pointer and length.
        -:  538:  template<typename T>
        -:  539:  MutableArrayRef<T> makeMutableArrayRef(T *data, size_t length) {
        -:  540:    return MutableArrayRef<T>(data, length);
        -:  541:  }
        -:  542:
        -:  543:  /// Construct a MutableArrayRef from a SmallVector.
        -:  544:  template <typename T>
        -:  545:  MutableArrayRef<T> makeMutableArrayRef(SmallVectorImpl<T> &Vec) {
        -:  546:    return Vec;
        -:  547:  }
        -:  548:
        -:  549:  /// Construct a MutableArrayRef from a SmallVector.
        -:  550:  template <typename T, unsigned N>
        -:  551:  MutableArrayRef<T> makeMutableArrayRef(SmallVector<T, N> &Vec) {
        -:  552:    return Vec;
        -:  553:  }
        -:  554:
        -:  555:  /// Construct a MutableArrayRef from a std::vector.
        -:  556:  template<typename T>
        -:  557:  MutableArrayRef<T> makeMutableArrayRef(std::vector<T> &Vec) {
        -:  558:    return Vec;
        -:  559:  }
        -:  560:
        -:  561:  /// Construct a MutableArrayRef from a std::array.
        -:  562:  template <typename T, std::size_t N>
        -:  563:  MutableArrayRef<T> makeMutableArrayRef(std::array<T, N> &Arr) {
        -:  564:    return Arr;
        -:  565:  }
        -:  566:
        -:  567:  /// Construct a MutableArrayRef from a MutableArrayRef (no-op) (const)
        -:  568:  template <typename T>
        -:  569:  MutableArrayRef<T> makeMutableArrayRef(const MutableArrayRef<T> &Vec) {
        -:  570:    return Vec;
        -:  571:  }
        -:  572:
        -:  573:  /// Construct a MutableArrayRef from a C array.
        -:  574:  template<typename T, size_t N>
        -:  575:  MutableArrayRef<T> makeMutableArrayRef(T (&Arr)[N]) {
        -:  576:    return MutableArrayRef<T>(Arr);
        -:  577:  }
        -:  578:
        -:  579:  /// @}
        -:  580:  /// @name ArrayRef Comparison Operators
        -:  581:  /// @{
        -:  582:
        -:  583:  template<typename T>
        -:  584:  inline bool operator==(ArrayRef<T> LHS, ArrayRef<T> RHS) {
        -:  585:    return LHS.equals(RHS);
        -:  586:  }
        -:  587:
        -:  588:  template <typename T>
        -:  589:  inline bool operator==(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {
        -:  590:    return ArrayRef<T>(LHS).equals(RHS);
        -:  591:  }
        -:  592:
        -:  593:  template <typename T>
        -:  594:  inline bool operator!=(ArrayRef<T> LHS, ArrayRef<T> RHS) {
        -:  595:    return !(LHS == RHS);
        -:  596:  }
        -:  597:
        -:  598:  template <typename T>
        -:  599:  inline bool operator!=(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {
        -:  600:    return !(LHS == RHS);
        -:  601:  }
        -:  602:
        -:  603:  /// @}
        -:  604:
        -:  605:  template <typename T> hash_code hash_value(ArrayRef<T> S) {
        -:  606:    return hash_combine_range(S.begin(), S.end());
        -:  607:  }
        -:  608:
        -:  609:  // Provide DenseMapInfo for ArrayRefs.
        -:  610:  template <typename T> struct DenseMapInfo<ArrayRef<T>, void> {
        -:  611:    static inline ArrayRef<T> getEmptyKey() {
        -:  612:      return ArrayRef<T>(
        -:  613:          reinterpret_cast<const T *>(~static_cast<uintptr_t>(0)), size_t(0));
        -:  614:    }
        -:  615:
        -:  616:    static inline ArrayRef<T> getTombstoneKey() {
        -:  617:      return ArrayRef<T>(
        -:  618:          reinterpret_cast<const T *>(~static_cast<uintptr_t>(1)), size_t(0));
        -:  619:    }
        -:  620:
        -:  621:    static unsigned getHashValue(ArrayRef<T> Val) {
        -:  622:      assert(Val.data() != getEmptyKey().data() &&
        -:  623:             "Cannot hash the empty key!");
        -:  624:      assert(Val.data() != getTombstoneKey().data() &&
        -:  625:             "Cannot hash the tombstone key!");
        -:  626:      return (unsigned)(hash_value(Val));
        -:  627:    }
        -:  628:
        -:  629:    static bool isEqual(ArrayRef<T> LHS, ArrayRef<T> RHS) {
        -:  630:      if (RHS.data() == getEmptyKey().data())
        -:  631:        return LHS.data() == getEmptyKey().data();
        -:  632:      if (RHS.data() == getTombstoneKey().data())
        -:  633:        return LHS.data() == getTombstoneKey().data();
        -:  634:      return LHS == RHS;
        -:  635:    }
        -:  636:  };
        -:  637:
        -:  638:} // end namespace llvm
        -:  639:
        -:  640:#endif // LLVM_ADT_ARRAYREF_H
